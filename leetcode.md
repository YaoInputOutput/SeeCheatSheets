# 临界条件
* **下标越界（指导方针）**
    > 特别注意size_t类型数据的减法
* 极小容器
* 前后依赖
* 循环边界

**解决**：
* 考虑提前处理掉极端临界条件
* 考虑使用极大（小）值等方法来实现 **静默处理**
* 考虑交换大小值以保证其中一值固定为较小值从而实现 **静默处理** 

# 逆向思维
* 求起点的终点转为求终点的起点
* 对多个元素进行操作，相当于对其他元素进行相对逆操作
* 由结论出发，向所求条件逆推

# 栈
## 辅助栈
**关键字**：层级、递归、存储FIFO表当前某一结果
> 需要返回上级才有必要用栈
* 在辅助栈中压入当前结果供后续入栈元素使用，而不影响之前的结果
* 在主栈弹出当前元素时，判断是否需要弹出辅助栈中的结果
* 实例：递归时在栈中压入某一数据，供下一次递归使用。若结果不正确则在返回之前弹出元素，若正确则返回给上级调用

## 单调栈
**关键字**：单调排列、最近的大（小）值

> 以单调递减栈为例
* 对出栈元素来说：
    * 入栈元素是其右侧最近的较大值
* 对入栈元素来说：
    * 栈里的元素即其左侧单调排列的元素（忽略破坏单调性的元素）
    * 入栈成功后，栈顶第二个元素即其左侧最近的较大值

# 队列
## 辅助队列
**关键字**：先进先出（时间）
## 单调队列
**关键字**：滑动窗口

# 链表
* 双指针，一前一后
* 双指针，间隔距离
* 双指针，一快一慢
* 哑节点，简化边界

# 二叉树
* DFS（递归）
    * 先序
    * 中序
    * 后序
* BFS（队列）

# 二分搜索算法
**关键字**：有序序列搜索

* 选取`right`做语义边界
```cpp
    if ( check(mid) )
        right = mid; // left作为循环不变量始终维护该语义
        // 不用left做语义边界的原因是mid向下取整，若left = mid则会死循环
```
* 选取`left`做驱动边界
```cpp
    else
        left = mid - 1;
```
* 循环终止时`right`语义仍然有效，且其作为此语义范围的边界

# 数组遍历算法
* 辅助记忆表
    * 覆盖型
    * 叠加型
    * 抵消型
    * 语义型
* 逆向首尾
* 滑动窗口
