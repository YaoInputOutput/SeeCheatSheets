# 极端条件
* 下标越界（指导方针）
* 空容器
* 操作首尾元素
* 循环条件检测保证当前节点有效，但其前后节点可能不存在
* 循环终止状态

**解决**：
* 提前处理掉极端条件
* 考虑使用极大（小）值等方法来实现 **静默处理**
* 考虑交换大小值以保证其中一值固定为较小值从而实现 **静默处理** 

# 辅助栈
**关键字**：层级、递归、存储FIFO表当前某一结果

* 在辅助栈中压入当前结果供后续入栈元素使用，而不影响之前的结果
* 在主栈弹出当前元素时，判断是否需要弹出辅助栈中的结果
* 实例：递归时在栈中压入某一数据，供下一次递归使用。若结果不正确则在返回之前弹出元素，若正确则返回给上级调用

# 语法栈
**关键字**：配对符解析

* 将待解析字符入栈，遇到右配对符即弹出栈中元素直到左配对符，解析完后将结果压入

# 单调栈
**关键字**：单调排列、最近的大（小）值

> 以单调递减栈为例
* 对出栈元素来说：
    * 入栈元素是其右侧最近的较大值
* 对入栈元素来说：
    * 栈里的元素即其左侧单调排列的元素（忽略破坏单调性的元素）
    * 入栈成功后，栈顶第二个元素即其左侧最近的较大值

# Skip遍历优化
**关键字**：O(n²)遍历序列

* 前一次遍历结果可以为后一次遍历缩短长度，即后一次遍历可跳过一些对结果无影响的元素


# 二分搜索
**关键字**：有序序列搜索

* 二分遍历（一）`while begin != end` `begin = center + 1` `end = center`
    > 特点是center可能的范围是[begin, end)
* 二分遍历（二）`while begin <= end` `begin = center + 1` `end = center - 1`
    > 特点是center可能的范围是[begin, end]
* 计算中点`center = (begin + end) / 2`，并确定中点语义


