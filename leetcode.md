# 逆向思维
* 求起点的终点转为求终点的起点
* 对多个元素进行操作，相当于对其他元素进行相对逆操作
* 由结论出发，向所求条件逆推

# 边界条件
* 数值限制
    * 整数（U负溢出、-Tmin、除零）
    * 浮点（有效、结合、比较）
    * 指针（nullptr）
* 容器循环
    * 极小容器
    * 前后依赖
    * 循环边界

**解决方案**：
* 考虑提前处理掉极端临界条件
* 考虑使用极大/小值来避开边界检测
* 考虑反转大小值来简化代码

**用户接口**：
* 发射信号
* 抛出异常
* 静默处理

# 循环
* 变，语，迭    > if-continue
* 条，穷，相    > if-break
* 操，记，初    > once

**补充**：
* 相关关系：
    * 若在条件检测中使用 **前缀** 自增或自减会导致
        **检测前初始状态** 额外地+1，但仍属于 **检测最后状态+1** 
    * 若在条件检测中使用 **后缀** 自增或自减会导致
        **检测后初始状态** 与 **最后状态** 额外地+1，属于 **检测最后状态**

* 循环计数器：空操作，可视作迭前或迭后
    * 迭后，则初始状态为S，计数N步，最后状态+1则为S+N
    * 迭前，则初始状态为S+1，计数N步，最后状态则为S+1+N-1==0

* 初始状态：
    * 若构造循环 **初始状态** 的代码与循环体内片段重复，则用if-break代替 **条件检测** 从而将其融合进循环体

* 如果第一次循环存在特殊操作：
    * 改变初始状态，将第一次循环操作抽出
    * 利用once标识，只在第一次循环执行特殊操作
    * 观察是否可转换为最后一次循环做特殊操作

* 如果最后一次循环存在特殊操作：
    * 改变条件检测，将最后一次循环操作抽出
    * 利用if-break代替头部条件检测，在最后一次循环时执行特殊操作
    * 观察是否可转换为第一次循环做特殊操作


# 分支
* if-if
* if-else if-continue if-break if-return if-exit
* if-elif-else  `<=>` if-else{if-else}
* if{for}       ` =>` for
* 多if `=>` switch `=>` 跳转表（数组） `=>`跳转表（hash表）

> 对于if-elif-else  `<=>` if-else{if-else}：
> * 保证合并后的else条件包含原来两分支的条件，即逻辑或语义
> * 有时两分支的条件检测有部分重叠时，也可合并两分支
<!-- entry end -->

<!-- entry begin: logic  递归 -->
# 递归
* 明确功能：参数，返回值，所有副作用
* 基准情况：结束递归，并符合上述功能
* 一般进展：利用递归获取下层结果，与本层计算结合得到本层结果
* 尾递归：转为循环
<!-- entry end -->

# 步数
获取数量：
* `[X0, Xn]`
* Xn - X0 + 1

获取距离：
* `(X0, Xn]`
* Xn - X0

获取尾后向量：
* Xn + 数量

获取尾部向量：
* Xn + 距离


# 栈
## 辅助栈
**关键字**：层级、递归、存储FIFO表当前某一结果
> 需要返回上级才有必要用栈
* 在辅助栈中压入当前结果供后续入栈元素使用，而不影响之前的结果
* 在主栈弹出当前元素时，判断是否需要弹出辅助栈中的结果
* 实例：递归时在栈中压入某一数据，供下一次递归使用。若结果不正确则在返回之前弹出元素，若正确则返回给上级调用

## 单调栈
**关键字**：单调排列、最近的大（小）值

> 以单调递减栈为例
* 对出栈元素来说：
    * 入栈元素是其右侧最近的较大值
* 对入栈元素来说：
    * 栈里的元素即其左侧单调排列的元素（忽略破坏单调性的元素）
    * 入栈成功后，栈顶第二个元素即其左侧最近的较大值

# 队列
## 辅助队列
**关键字**：先进先出（时间）
## 单调队列
**关键字**：滑动窗口

# 链表
* 双指针，一前一后
* 双指针，间隔距离
* 双指针，一快一慢
* 哑节点，简化边界

# 二叉树
* DFS（递归）
    * 先序
    * 中序
    * 后序
* BFS（队列）

# 二分搜索算法
**关键字**：有序序列搜索

* 选取`right`做语义边界
```cpp
    if ( check(mid) )
        right = mid; // left作为循环不变量始终维护该语义
        // 不用left做语义边界的原因是mid向下取整，若left = mid则会死循环
```
* 选取`left`做驱动边界
```cpp
    else
        left = mid + 1;
```
* 循环终止时`right`语义仍然有效，且其作为此语义范围的边界

# 数组遍历算法
* 辅助记忆表
    * 覆盖型
    * 叠加型
    * 抵消型
    * 语义型
* 逆向首尾
* 滑动窗口

# 回溯算法
**关键字**：路径搜索、路径染色
# 动态规划
**关键字**：数组、矩阵、递归、记忆表

# topK算法
| 数据结构 | 描述                                           | 动态/静态 |
|----------|------------------------------------------------|-----------|
| 数组     | 快速选择算法O(N)                               | 静态      |
| 数组     | 插入有序数组O(N)，随机访问topK O(1)            | 动态      |
| 链表     | 插入有序链表O(N)，访问topK O(K)                | 动态      |
| 红黑树   | 插入O(log(N))，中序遍历获取topK O(log(N))      | 动态      |
| 最小堆   | 维护topK的最小堆，插入O(log(K))，访问topK O(1) | 动态      |

**扩展：求中位数(No.K)**
| 数据结构       | 描述                                                                                | 静态/动态 |
|----------------|-------------------------------------------------------------------------------------|-----------|
| 数组           | 快速选择算法O(N)                                                                    | 静态      |
| 数组           | 插入有序数组O(N)，随机访问中位数O(1)                                                | 动态      |
| 链表           | 维护两个指向中间节点的指针，插入有序链表O(N)，访问中位数O(1)                        | 动态      |
| 红黑树         | 每个节点维护该子树的节点数，插入O(log(N))，访问中位数O(log(N))                      | 动态      |
| AVL树          | 用两子树的节点数做平衡因子，插入O(log(N))，访问中位数O(1)                           | 动态      |
| 最小堆与最大堆 | 使大数最小堆与小数最大堆的大小平衡，先插入小数最大堆，插入O(log(N))，访问中位数O(1) | 动态      |

**扩展：求频度topK，动态插入且频度可变**
| 数据结构               | 描述                                                                                           |
|------------------------|------------------------------------------------------------------------------------------------|
| 链表 + hash表          | hash表(id, ptr+data)，插入O(N)，删除O(1)，更改O(N)，访问O(1)，若频度非突变则插入与更改接近O(1) |
| 红黑树/跳跃表 + hash表 | hash表(id, ptr+data)，插入O(log(N))，删除O(log(N))，更改O(log(N))，访问O(1)                    |


# 海量数据处理
**注意**：整数的重复性有关的哈希统计可考虑Bloom Filter或bitmap

* 问：找出文件A、B的共同数据？
* 答：哈希取模，文件作桶，哈希统计，依序对比


* 问：找出海量数据中的（不）重复值？
* 答：哈希取模，文件作桶，哈希统计


* 问：统计海量数据的频度？
* 答：哈希取模，文件作桶，哈希统计


* 问：对海量数据进行排序？
* 答：分块，排序，归并


* 问：海量数据中找出topK？
* 答：动态topK算法：维护红黑树节点子树大小、维护topK最小堆


* 问：分布式处理，海量数据分布在N台主机中，求topK
* 答：每台主机求topK，然后汇总归并取前K


* 问：分布式处理，海量数据分步在M台主机中，求频度topK
* 答：哈希取模，主机作桶，哈希统计，求topK，汇总归并取前K


* 问：海量字符串去重
* 答：trie tree


