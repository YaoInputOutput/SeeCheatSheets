# 项目
## SeeCheatSheets
这个项目囊括了我个人所学的绝大多数知识与技能，
包括，比如C++、Linux、Python、MySQL、Docker以及计算机基础知识、底层知识等等；

其中特别是C++与Linux相关的的几篇文章，平均每篇都写有3万字，
而且这几篇文章每篇都至少重写了有3遍，每次重写都是对知识的重新整理与加深理解；

这相当于是费曼学习法吧，每次写文章都是一个与自己对话的过程，给自己解释每一个知识点，
最后将知识吸收变为自己的理解然后记录都文章里。

除了这些理解性的知识之外，仓库里还有许多记忆性的知识，比如C++标准库、Unix系统接口、Linux命令参数等等；
为了方便快速查询这些笔记，仓库里还提供了一支由C++构建的程序，用于根据关键字快速地搜索笔记。

除了搜索笔记，这个程序更重要的功能其实在于对markdown文本的语法高亮。
这些文章笔记都是用markdown语法写的，程序将包含关键字的片段搜索出来后需要对它们进行语法高亮。
利用ANSI escape序列对文本进行着色然后在终端将其打印出来。
项目的github主页上有展示了语法高亮的效果图。

技术上的特点话，主要就是围绕其可扩展性吧，因为markdown语法繁多，官方都没有统一标准，
所有很有必要去思考如何提高程序的可扩展性；

我的设计上呢，就是为不同的语法模块设计一个抽象基类，这个抽象基类的接口呢大致有3个：
* 第一个方法用于判断是否进入该语法块
* 第二个方法用于判断是否结束当前语法块
* 第三个就是对当前语法块中的文本进行语法解析

但这时候问题出现了，因为基于这个设计上，一个语法块可能依赖于另一个类型的语法块；
比如说，大多数语法块都依赖解析普通段落的语法块，还有比如判断是否结束列表语法区块就依赖于当前行是否是引用语法块的开头；
这时候为了降低各个语法模块间直接相互引用而导致的耦合，就需要引入中介者模式；
各个语法模块与其他语法模块间的调用都需要通过中介者来进行，这样每个语法模块都可以独立的改变而不影响到其他模块，
只需要功能上相同的模块向中介者注册的时候保持相同的键值，实现上就是在中介者内部用哈希表键值对来存储各语法模块的指针，
语法模块就作为同事类；
同时，因为中介者聚集了各个语法模块而形成一个用于语法高亮解析完整的Markdown语法的语法模块，这样中介者页算是一个表观类吧；

除此之外，还有一个特点是，我在语法模块的抽象基类的构造函数中做了手脚，
使得所有派生自它的子类在构造其对象实例时都自动地向中介者注册自身，这就需要在这之前有一个中介者实例对象；
为了实现这个功能，我将之前说的中介者类再加一层设计模式，把它设计成单例模式；
这样我们就可以直接向那个单例注册自身，而用户也只能使用这个单例来对markdown进行语法解析；

这样设计下来，每当我们添加一个语法高亮模块时，就先派生自抽象基类，然后实现基类接口，
最后定义一个静态变量，当程序启动时，在调用main函数之前，会先调用静态变量的构造函数，
这样就会调用基类的构造函数，然后向中介者单例注册自身。

这里有个问题就是，多文件编译时静态变量的构造顺序是未定义的，
很可能语法模块注册自身时中介者还没构造，从而导致错误行为；
这时候就需要reference-return技术来实现单例模式，就是设计一个函数并返回函数的局部静态变量。
这样在使用中介者之前，中介者必定已经构造；而且如果不使用中介者，则会省去不必要的构造开销；
因为函数局部变量在第一次调用时才会初始化，同时C++标准保证了函数局部静态变量的线程安全性；
这应该算是最简单的一种单例模式了吧；

大概设计架构就是这样，剩下的就是语法解析算法的实现了。

* 问：如何实现在基类构造函数中注册派生类实例？
* 答：这就涉及到C++的多态原理。派生类的数据成员其实可看作两部分，一个是派生类部分，一个是基类部分。
如果类中定义了有虚函数，就会引入一个隐式的数据成员——虚指针，虚指针指向虚表，
虚表里存储了虚指针所在类的运行时的真实类型信息，以及该运行时类型的虚函数入口地址；
派生类部分与基类部分都有虚指针，所以我们基类的this指针就相当于把派生类的指针转换为基类指针，从而形成多态，
然后通过指针调用虚函数时，就会根据指针找到虚表，然后找到相应的虚函数入口地址，这个过程就是动态绑定。

* 问：为什么要将中介者设计成单例模式？
* 答：因为想要在基类构造函数中就实现注册派生类实例，就必须提前知道中介者类的实例。
如果用全局变量实现这个实例的话，用户很可能不会使用这个全局变量；
所以就用单例模式，这样开发者与用户都会使用相同的中介者。
当然这种设计会一定程度的降低可扩展性，因为语法模块都是直接引用的中介者类，导致扩展中介者类时很麻烦。
当然，其实这也不算问题，因为扩展中介者类就意味着我们想要扩展不同的markdown语法版本，
比如github风味的版本或者其他版本。我将各个语法模块都分离到单独的源文件中，并用头文件做接口桥梁。
这样一来，当我们想使用不同的markdown版本，就只需要引入不同版本对应的语法模块的头文件，进行排列组合即可。
只是这样一来，在运行时就只能有一个版本，但对我来说这是可接受的，毕竟这种设计很方便也很有趣。

如果正常设计的话，就老老实实地手动向中介者注册语法模块，对中介者类进行派生以形成不同版本风味的markdown语法。

## DotFiles
这个项目其实也没啥说的，就是作为两年多的Linux用户、Linux的热爱者，我自己所积累下来的整个开发环境的配置。
项目里提供了一个Shell脚本，可完整的还原我自己的整个开发环境，方便我重装，俗称“折腾”嘛。
折腾了两年下来，其实更重要的是这个过程而非结果。
这期间我学会了独立自主地去发现问题、定位问题、搜索解决方案、尝试自己解决，
经常不得不去思考那些工具的设计原理，想着如果我来设计应该怎么做，这确实是种能力的锻炼。
比如，我经常访问github会受到域名污染的问题，特别是校园网。
一开始我不知道域名污染，我想应该不止我一个人访问github很慢吧，我就去搜“github访问很慢怎么办”？
结果就知道了，哦，是域名污染的原因，根据我学的计算机网络的知识，知道DNS在网络中扮演什么样的角色，
也就明白为什么改hosts文件会有效果。

后来不满改hosts的方法非常麻烦，特别是对于github博客的域名，就是github.io，每个博客的域名都是不一样的，
所以没法通过修改hosts文件来解决，于是我就想，有没有方法从根上解决域名污染呢？
诶，我就想到直接用github的权威DNS服务器，这样就不会有域名污染的问题了吧。
实验呢很成功，但是速度有点感人，太慢了。然后我就想，能不能对于指定的域名使用指定的DNS服务器来解析呢。
然后我就去搜，在stackoverflow上找到了答案，说是linux内核并不支持这样做，需要自己搭建DNS服务器。
然后就顺藤摸瓜，了解到NetworkManager服务，了解到dnsmasq服务，当然其中还有一些问题，不过最终都被我解决了。

就这样，问题一个一个得被解决，配置越来越多，开发环境越来越舒服。
所以这个项目对我来说，是一个我成长的过程吧。

## SpaceVim
SpaceVim是一个社区驱动开发的模块化的vim发行版，它利用模块的形式来管理插件集合。
这是一个非常棒的设计，因为当我们作为开源贡献者发现项目里有一些问题、bug或者想要添加一些特性时，
我们可以根据这样模块化的设计，很容易找到相应目标源文件，然后进行修改。
真的是哪里不顺改哪里，精准打击。

我作为其中一个开源贡献者，虽然贡献不多，提交PR的次数很少。
但我在我自己fork的分支版本中修改了大量的源码，总共变更了有46个源文件，累计修改了将近4000行源码。
这其中其实有很多是我想合并到上游的，但是碍于时间就一直搁置着，等以后有空了还与上游维护者沟通一下。
当然，更多了其实是我自己的比较个性化的配置，并不适合合并到上游，比如说快捷键设置呀等等。

这个项目对我来说的话，技术上没有特别难的点，特别难的都让上游给做了。
对我自己来说的话，更多的是解决各种各样的bug吧。
比如说，其中有一个SpaceVim自带插件，用于在多个文件中搜索目标文本。
它会把搜索到的目标文本行在一个窗口中展示出来，同时会对匹配到的字符进行语法高亮。
有次出了一个bug，就是忽略大小写匹配时，比如说输入小写字母，匹配到了大写字母，但是大写字母并没有被高亮。
我知道这问题大概就出现在设置语法高亮时的大小写配置与搜索时不一样导致的，
于是我就是该插件对应的源文件里找，搜索关键字，定位到问题在哪后就开始尝试修改。

但是由于整个项目基本上都是使用vim自带的脚本实现的，我自己对vim的各个api函数不太了解，
所以经常需要边修改边去查阅文档，现学现卖，甚至有些时候还要和上游维护者交流一下，向它们请教一下。
项目的维护者们建了有在线聊天室，经常有问题就会在聊天室里提出来，商量解决方案。
当需要正式修改的时候就要走在流程，先提issue，再提pr，最后review合并。
因为我经常在群里发言，他们就注意到了我自己fork的分支版本，觉得很不错，说我要是觉得有什么特性可以合并的提pr就行。

整个项目对我而言，其实是对我自身综合能力的锻炼吧，毕竟这么大个项目，团队合作很重要。
而且这也是我自身第一次大量的阅读别人的源码，而且还是自己没熟练掌握的语言，
所以对我而言，需要大量的思考别人的设计，才能修改成我想要的样子。


* 问：怎么得到4000行这个数据的呢？
* 答：就是用grep和awk编辑三剑客处理一下git diff的输出得到的。在git diff的输出中，-号开头表示删除，
+号开头表示添加，我就计算一下+号开头的有多少行，结果大概就是3800行左右。

# 反问
* 项目组里C++标准大概都是用的哪版？
* 需要我补充哪方面的知识或者锻炼哪方面能力呢？

# HR问答
* 问：有考研的打算吗？
* 答：并没有打算考研。因为为从自己的观察呀、从网上呀、还有包括鹅厂wo谈会上，
有个面试官就说，从他的经验上来看，研究生和本科生的能力差别其实并不大，而且本科生在本科阶段就获取的能力
可能就比研究生多花了几年时间获得的能力差一点点。他说，这么看来其实本科生还是有点优势的。
我自己也很认同这个观点，对我来讲，考研对比工作的优势仅仅在于那一纸文凭，而对于能力的提升的话我觉得肯定是直接工作要更好。
而且如果秋招有机会的话，我也希望能来腾讯，来微信。
虽然我第一志愿投的是IEG，但是并代表我真的想去IEG。
就像我当年添高考志愿选专业的时候，其实我们学生哪对这些专业了解这么多呀，都是凭主观意向随意选的。
既然这次微信把我捞了，我当然是很感谢微信的，而且那期鹅厂wo谈会就讲的微信，我觉得微信真得很好啊。
所以我很愿意加入微信，而不是考研。


