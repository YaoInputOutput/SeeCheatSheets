# 自我介绍
面试官您好，我是来自天津工业大学22届的本科学生，我叫熊海成。

可能您看到我的简历会比较好奇我的本科专业，对，没错，我的本科专业就是大名鼎鼎的四大天坑之一——材料。
当年添志愿的时候本来计算机是排在最前面的，结果阴差阳错地又把材料调到了前面，
后来又发生了一系列的事情触动了我，最后决定自学计算机，然后就这样一步步的靠自己走到现在，
接触了C++、接触了Linux、接触了开源社区。
这期间锻炼了我很多能力，特别是独立思考与学习的能力、解决问题和沟通的能力；
也学到了很多知识，像C++、Linux、MySQL、Docker等等，
特别是计算机的基础知识，因为我自己非科班嘛，所有我特别重视基础，这样我以后才能有更好发展潜力。
嗯，以上大概就是我想说的关于自我的介绍。


# 项目
## SeeCheatSheets
这个项目本来的目的是作为一个我个人学习笔记仓库，囊括了我个人所学的绝大多数知识与技能，
仓库里一共包含了30多篇用markdown撰写的文章笔记，总计40多万字，都是我的知识结晶。
项目的目的本来是为了整理自己所学的知识，相当与一个思维导图，让我可以很方便的随时复习，加深印象。

> 这相当于是费曼学习法吧，每次写文章作笔记都是一个与自己对话的过程，给自己讲解每一个知识点，
> 最后将知识吸收变为自己的理解然后记录都文章里。

后来呢，因为项目里有许多记忆性的知识，比如C++标准库、POSIX API、Linux命令参数等等；
虽然这些大多都记得，我有刻意的去背、去记忆这些，但总有时候还是需要查询。

为了方便快速查询这些笔记，我用C++编写构建了一支程序，
可以根据关键字快速地搜索笔记片段并利用ANSI转义序列对markdown文本进行语法解析并高亮。
因为我平时学习和生产环境都是在终端命令行里进行的，所以查询结果直接在终端打印出来，很方便。
如果文本显示超出屏幕宽度还会将结果通过管道送给pager程序显示。
项目的github主页上展示了有效果图。

技术上的特点话，主要就是围绕“可扩展性”进行设计；
因为markdown本身语法由许多语法区块构成，比如列表区块、引用区块、代码区块等等；
而且，不同版本的markdown语法都有各自独特的语法元素，比如比较流行github风味的版本就支持@用户和提及issue等等，
markdown的作者都没有官方地统一标准，所有很有必要去思考如何提高程序的可扩展性；

我的设计上呢，首先就是为不同的语法模块设计一个抽象基类，这个抽象基类的接口大致有3个：
* 第一个方法用于判断当前行是否为某语法区块的开头
* 第二个方法用于判断当前行是否为某语法区块的结尾
* 第三个方法就是对开头到结尾之间的文本内容进行语法解析并高亮

但这儿有个问题就是，一个类型的语法模块可能依赖于另一个类型的语法模块；
比如说，判断是否结束“列表区块”就依赖于当前行是否是引用区块的开头、代码区块的开头等等，
还有比如，大多数语法区块都依赖“解析普通段落的语法区块”，用它的语法高亮方法来解析部分内容；

如果各个语法模块之间直接相互引用的话，将类型信息硬编码进代码中，
就会导致模块间非常高的耦合度，从而导致各个模块没法独立的变换扩展，
只要对一个模块进行修改扩展，就要同时修改其他所有依赖它的模块；
这时候为了降低各个语法模块间直接相互引用而导致的耦合，就需要引入“中介者模式”；

首先我需要设计一个中介者类，所有属于同一个markdown语法版本的语法模块都向同一个中介者注册自身，
各个语法模块与其他语法模块间的相互调用都需要通过中介者来进行，
这样每个语法模块都可以独立的修改扩展而不影响到其他模块，
实现上就是在中介者内部用哈希表键值对来存储各语法模块的指针，
注册时，比如列表区块就注册键值为list，引用区块就注册键值为quote等等；

同时，因为中介者聚集封装了各个语法模块而形成一个用于完整Markdown语法模块，
这样中介者去除也算是一个表观模式中的表观类吧；
很自然的，我只需要一个中介者，所以又将这个中介者设计成单例模式；

除此之外，还有一个特点是，语法模块的抽象基类的构造函数比较特殊，
所有派生自它的子类在构造其对象实例时都自动地向中介者单例注册自身；

这样设计下来，每当我们要设计添加一个语法高亮模块时，
* 就先派生自抽象基类，
* 然后实现基类接口，
* 最后定义一个静态变量；

当程序启动后，在调用main函数之前，会先调用静态变量的构造函数，
这样就会调用基类的构造函数，然后自动地向中介者单例注册那些引入的语法模块。
而语法模块的设计分为两部分，两个文件，
* 一个是头文件，里面有派生类的定义，以及该派生类的一个inline的静态变量，
* 另一个是实现文件，就是实现了头文件中的接口。

这样，只要在主模块文件中include语法模块的头文件，就相当于自动引入了该语法模块。
想要修改Markdown版本，实现新的语法模块，然后引入新的头文件就行了。

这个设计最大的问题在于，引入的头文件模块都自动的向一个中介者注册自身，
所以运行时只能同时存在一个Markdown语法版本，这对于我自己来说是可接受的，而且这种设计更方便也更有趣；

如果正常设计的话，就老老实实地在中介者的构造函数中手动注册各个版本的语法模块，形成完整的markdown语法模块。
不同版本的markdown语法就只要将各个版本的语法模块组装起来就行了。

大概设计架构就是这样，剩下的就是语法解析算法的实现了。
解析算法上比较特殊的就是标题区块与代码区块的语法解析吧，
这两个语法模块解析都需要获取终端窗口大小，这就需要调用Posix标准的系统api来获取，
同时也需要计算每一行字符的显示宽度，这就涉及到了简历上第四个项目了。
最后的话，就是普通段落区块的解析算法比较麻烦，需要用栈来记录行内emphasize元素的开启与关闭，
比如斜体粗体呀、内联代码、下划线等等，关闭的时候需要结束当前元素颜色显示，同时恢复外层元素的颜色显示。

* 问：如何实现在基类构造函数中注册派生类实例？
* 答：这就涉及到C++的多态原理。派生类的数据成员其实可看作两部分，一个是派生类部分，一个是基类部分。
如果类中定义了有虚函数，就会引入一个隐式的数据成员——虚指针，虚指针指向虚表，
虚表里存储了虚指针所在类的运行时的真实类型信息，以及该运行时类型的虚函数入口地址；
派生类部分与基类部分都有虚指针，所以我们基类的this指针就相当于把派生类的指针转换为基类指针，从而形成多态，
然后通过指针调用虚函数时，就会根据指针找到虚表，然后找到相应的虚函数入口地址，这个过程就是动态绑定。


## DotFiles
这个项目其实也没啥说的，就是作为两年多的Linux用户、Linux的热爱者，我自己所积累下来的整个开发环境的配置。
项目里提供了一个Shell脚本，可完整的还原我自己的整个开发环境，方便我重装，
俗称“折腾”嘛，linux用户都挺爱折腾的。
折腾的过程中我们得不断的去思考，
不断地去发现问题、定位问题、搜索解决方案、尝试自己解决，经常会引发我自己去思考一些底层的设计原理。
这确实是很锻炼一个人的独立思考能力、解决问题的能力和意志力。
折腾了两年下来，其实更重要的是这个过程而非结果。这个项目也是记录了我个人的成长过程吧。

比如国内DNS污染问题，我经常访问github会受到域名污染的问题，特别是校园网。
一开始我不知道域名污染，我想应该不止我一个人访问github很慢吧，我就去搜“github访问很慢怎么办”？
结果就知道了，哦，是域名污染的原因，根据我学的计算机网络的知识，知道DNS在网络中扮演什么样的角色，
也就明白为什么改hosts文件会有效果。

后来不满改hosts的方法非常麻烦，特别是对于github博客的域名，就是github.io，每个博客的域名都是不一样的，
所以没法通过修改hosts文件来解决，于是我就想，有没有其他方法从根上解决域名污染呢？
诶，我就想到直接用github的权威DNS服务器，这样就不会有域名污染的问题了吧。
实验倒是成功了，但是速度有点感人，太慢了。
然后我就想，能不能只对github的域名使用他家权威DNS服务器，就是对于指定的域名使用指定的DNS服务器来解析。
然后我就去搜，在stackoverflow上找到了答案，说是linux内核并不支持这样做，需要自己搭建DNS服务器。
然后就顺藤摸瓜，去修改NetworkManager服务的配置，让NetworkManager将DHCP获取的DNS服务器IP写到另一个文件中去，
而将resolv.conf中的本地使用的DNS服务器地址改为本地回环地址，
然后手动通过systemd启动dnsmasq服务，然后让dnsmasq自动读取之前NetworkManager写入的本地DNS的IP地址，
作为默认的DNS服务器，然后配置当解析github的域名的时候使用github自己的DNS服务器

chfs、systemd、转发、SELinux、FreeDesktop

字体合成、终端、字体矢量图、字体回滚、搜索解决方法

就像这样，问题一个一个得被解决，配置越来越多，开发环境越来越舒服。
所以这个项目对我来说，是一个我成长的过程吧。

## SpaceVim
SpaceVim是一个社区驱动开发的模块化的vim发行版，它利用模块的形式来管理插件集合。
SpaceVim在2018年立项，我也在立项不久就接触SpaceVim。
当年vim配置那是群魔乱舞，百花齐放，现在有了SpaceVim其实很大程度上改善了这一状况，
因为在大多竞品当中，SpaceVim是社区最庞大，开发最活跃，功能最完善，文档最齐全的。
很大程度降低了vim的门槛，对新手更加友好。
上游维护者还希望我们在高校中推广SpaceVim，当然我都去推广我自己的fork分支版本了。

项目中模块化管理确实是一个非常棒的设计，如今SpaceVim有这么多包括我在内的贡献者其实模块化设计作了很大贡献。

我作为一个开源贡献者，累计提交了共3个PR，共修复了2个bug和1个特性增强；
1个bug是关于文件内容匹配搜索的大小写敏感问题，1个是关于上游插件更新接口导致的兼容性问题；
增强的特性是对一些插件的加载规则进行修改再加以测试，提高加载速度的同时保证用户的对此的透明性。

虽然贡献的不多，但我对于我自己的fork分支版本进行了大量的修改。
总共修改了有40多个源文件，累计修改了将近4000行源代码，同时还写了有比较完善的使用文档。

作为开源贡献者，同时也是SpaceVim社区中的一员，经常会参与讨论一些项目相关话题，
我想这也是会块源社区做贡献的一种方式。

有时会有新手问vim本身的如何去配置，我一般看到都会耐心跟他们讲解vim的各种概念和功能特性；

有时会交流一些技术问题，比如向他们学到的，通过适时检测vim的窗口布局来实现让一些辅助窗口不影响vim退出；

有时我也会提出一些我自己的设计，比如给快速运行插件添加个功能，通过匹配文件内容来自动添加一些参数，
比如我在C++中引入并发相关的头文件，就自动添加编译器参数`-lpthread`链接linux线程库，
还有用C重写计时器，可以计时更精准，我还可以添加功能来获取程序的退出码和中断信号。

团队合作中，沟通其实非常重要。

而且这也是我第一次大规模的阅读别人的代码，其实还是很有挑战的。


我就说说我自己作了哪些修改吧：
* * * * * * * * * *
* **图标**：基于文件名、基于vim内建类型
* * * * * * * * * *
* **自动补全**：语义补全引擎与结对符补全，issue，实现
* * * * * * * * * *
* **语法检测**：cppcheck、clangtidy
* * * * * * * * * *
* **颜色主题**：针对C++
* * * * * * * * * *
* **字符画**：独角兽、不可描述
* * * * * * * * * *
* **状态栏**：算法修改，根据当前窗口宽度来选择展示的内容，行列号
* * * * * * * * * *
* **Fcitx与Fcitx5**：四种状态、问过上游
* * * * * * * * * *
* **FlyGrep文件内容搜索**：大小写敏感，PR
* * * * * * * * * *
* **QuickRun快速代码运行**：替代上游
    * 内建终端（方便）
    * 计时器（Linux api、更精准、派生子进程、前台进程组、信号、返回码、中断信号）
    * CGroup限制内存使用
    * 自动检测时间戳
    * 窗口隔离
    * 参数设置（设置编译器参数、运行命令、IO重定向）
    * 无伤移植
* * * * * * * * * *
* **文件树**：绑定快捷键到GUI程序
* * * * * * * * * *
* **tmux**：交互
* * * * * * * * * *
* **C模块**：三个插件（语义补全引擎、语法检测引擎、我的代码快速运行插件）统一C++标准版本。
* * * * * * * * * *
* **文档**：精简齐全，不用过脑
* * * * * * * * * *


> 但是由于整个项目基本上都是使用vim自带的脚本实现的，我自己对vim的各个api函数不太了解，
> 所以经常需要边修改边去查阅文档，现学现卖，甚至有些时候还要和上游维护者交流一下，向它们请教一下。
> 项目的维护者们建了有在线聊天室，经常有问题就会在聊天室里提出来，商量解决方案。
> 当需要正式修改的时候就要走在流程，先提issue，再提pr，最后review合并。
> 因为我经常在群里发言，他们就注意到了我自己fork的分支版本，觉得很不错，说我要是觉得有什么特性可以合并的提pr就行。

整个项目对我而言，其实是对我自身综合能力的锻炼吧，毕竟这么大个项目，团队合作很重要。
而且这也是我自身第一次大量的阅读别人的源码，而且还是自己没熟练掌握的语言，
所以对我而言，需要大量的思考别人的设计，才能修改成我想要的样子。


# 技术反问
* 项目组里C++标准大概都是用的哪版？
* 项目组里的工作内容？
* 需要我补充哪方面的知识或者锻炼哪方面能力呢？


# HR面
**STAR法则**  
问题：请讲出一件你通过学习尽快胜任新的工作任务的事。追问：
1. 这件事发生在什么时候？                       ———————S
2. 你要从事的工作任务是什么？                   ———————T
3. 接到任务后你怎么办？                         ———————A
4. 你用了多长时间获得完成该任务所必须的知识？   ———————深层次了解
5. 你在这个过程中遇见困难了吗？                 ———————顺便了解坚韧性
6. 你最后完成任务的情况如何？                   ———————R

* 问：最有成就感的事情？
* 答：可能就是这两年来我靠自己一步步走到今天吧。
    我从大一下期决定自学计算机的，当时因为信念还不坚定导致错过了转专业的机会。
    这两年几乎每天都废寝忘食，夜以继日地学知识学技术，为的就是能够超过科班生；
    几乎把所有时间都花在计算机上，不过有学期我还挺意外的，居然拿了班上第5名，
    说明我学习能力还可以，还是有点小小成就感


* 问：经过努力克服的事？
* 答：还是技术相关的吧，都说万事开头难，别人都是“师父领进门，修行在个人”，我是连个便宜师傅都没有，
    刚开始自学的第一学期真的太痛苦了，好多东西都不会，甚至都不知道自己不知道什么，真的挺绝望的。
    然后每天都去网上搜资料，规划学习路线，然后买书来看。
    后来慢慢地把知识体系建立起来了，视野越来越宽，而且学习能力和学习习惯也养成了，
    学起来就顺畅多了，有种水到渠成的感觉，因为有这些基础知识体系，就能很好的理解甚至推导新知识新技术。
    比如学了计算机网络的基础知识，就能去推导怎么做内网穿透呀，去推导docker容器的网络模型呀之类的


* 问：你有什么缺点？
* 答：缺点就是注意力不集中，有时候看一句话要来来回回看几遍，但其实心思根本没在上面，
    这句子明明都是中文，但就是怎么看都看不懂。有时候就是单纯的走神，有时候其实是在回忆之前的学的知识点，
    想着要不要现在复习一下前面的知识点怕之后忘了，但经常这只是在浪费时间。
    不过有时候也得益于这种发散思维，将一些知识点联想起来，建立思维导图。
* 答：还有就是计划被打乱的时候会很难受，我每天会给自己安排第二天的任务，但计划赶不上变化，特别是在家的时候，
    杂事挺多的，经常打乱我的计划，导致任务被延迟甚至被取消，有的甚至导致我熬夜加班去补完任务。


* 问：期望薪资？
* 答：就技术面试官对我的评价，根据您的经验来看，我的薪酬范围应该是多少呢？
* 答2：
    * 参考对方公司公开薪资表
    * 参考上份工作×130%左右
    * 面试效果好就报高点，不好则报低点
    * 尽量把合同上的薪资谈高（月薪）


* 在 hr 面自己也可以问一问公司的一些情况，比如
    * 薪资结构
    * 年终奖
    * 五险一金
    * 加班情况
    * 加班费计算
    * 升职加薪的规章制度
    * 年假安排等

* 注意，技术面试官谈薪资时，答：“现在还不确定，HR需要综合评定。”（无法回避就报低点）


# 八股整理
## 操作系统
* 加法器
    * s1 = A ^ B
    * c1 = A & B
    * s2 = s1 ^ c
    * c2 = s1 & c
    * s  = s2
    * c  = c1 ^ c2

* 减法器
    * x - y
        = x + 1111 - y + 1 - 10000
        = x + ~y + 1
    * -y = ~y + 1

* 整形编码
    * 无符码与补码
    * 扩展、截断、转换
    * 求逆、加法、乘法

* 浮点数编码
    * 符号-阶码-尾数
    * 非规格化（正负0）、规格化、无穷、NaN
    * 精度：无结合律、近似比较

* 寄存器类型
    * PC
    * 通用
    * 浮点
    * 标识

* 进程内存布局（从低地址到高地址）
    * 代码段：ELF中的.text与.rodata区
        > .text保存机器指令，.rodata保存诸如字符串字面量与浮点数字面量；
        > x86指令浮点数没有立即数，所以需要存储到.rodata；而整数有立即数，可以直接存储到机器指令中
    * 数据段：ELF中的.data与.bss区
        > .data保存全局和静态变量，.bss保存为初始化或初始化为0的全局和静态变量，
        > 为节省空间，.bss中的变量只记录符号名而不分配空间，在加载时才分配内存并初始化为0
    * 堆：
        > 就是我们new表达式申请的内存空间，C++语言的内存分配器帮我们管理这片空间，
        > 可以进行内存分配、碎片整理、垃圾回收等等
    * 共享段：
        > 调用动态共享库时会将动态库的代码段和数据段映射到这里
    * 栈：
        > 保存运行时数据
    * 内核保留空间：起始于$2^48$
        * 内核代码与数据
        * 物理内存映射
        * 当前进程专属信息（task、thread_info、内核栈等等）

* 运行时栈
    * 函数参数
    * 返回地址
    * 被调用者保留寄存器值
    * 局部变量
        * 结构与数组
        * 取地址的变量
        * 寄存器不足

* 对抗缓冲区溢出攻击
    * 地址空间布局随机化(ASLR)
        > 运行时随机设置关键区域的地址空间，同时保证堆、共享段、栈的相对地址不变；
        > 随机化范围大约$2^32$，“空操作雪橇”暴力破解
    * 栈破坏检测
        > 在返回地址前面设置运行时随机的“金丝雀值”，并将该值放在只读寄存器中，函数返回前检测
    * 限制可执行代码区域

* 静态链接
    * 符号解析：将多个目标文件中的符号定义与符号引用绑定起来
        > 实现上维护三个集合：未绑定引用集合、定义集合、文件集合。链接器依次解析命令行参数文件
    * 重定位：将多个目标文件聚合成一个文件后，一些引用地址需要修改
        > 外部函数、内部全局变量、外部全局变量；
        > 内部函数(相对地址不变)

* 动态链接
    * 编译时：提取动态库符号信息
    * 启动时：调用链接器加载动态库
        > 动态库搜索路径：
        1. 可执行文件中指定
        2. 环境变量LD_LIBRARY_PATH指定
        3. 配置文件/etc/ld.so.cache指定
        4. 系统默认路径/lib
    * 内存映射：代码段母本、数据段副本（相对代码段位置不变）
    * 变量引用：立即绑定到GOT表
    * 函数引用：延迟绑定到PLT表

* 虚拟内存
    * 优点：
        * 使系统更高效地利用内存
            * 进程看起来连续的地址空间页面，实际上可能被分散地映射到了物理内存各处，系统可以很好的利用一些空间碎片
            * 进程的虚拟地址空间是可以映射到磁盘空间的，
                系统利用LRU算法会在内存紧张的时候将一些不常用的页面冲刷到磁盘swap空间，下次访问时再加载回来
        * 简化内存管理：
            * 为每个进程提供一致的地址空间，可以简化链接、简化加载、简化共享、简化内存分配
        * 内存保护机制：
            * 每个进程的地址空间都相对独立，从而避免地址空间被其它进程破坏
                > 不同进程中相同的虚拟地址一般映射到不同的物理地址，除非是共享段或者fork的子进程因为COW机制而与父进程暂时共享地址空间
    * 地址翻译：
        * 当CPU指令进行访存操作时，先将虚拟地址送给MMU进行翻译
        * 将虚拟地址分为两部分：虚拟页号与偏移量
        * 然后从页表基址寄存器读取页表起始地址访问页表（页表有单独的高速缓存TLB）
        * 根据页表进行索引，找到对应的物理页号；同时根据偏移量去高速缓存中找出可能的数据
        * 当翻译完成后检查提前找出的数据地址是否匹配，如果匹配就加速的数据访问，若不匹配则通过物理地址重新访问高速缓存
    * 页与段：
        * 页是内存分配的基本单位，段将连续的功能相同的页组织关联起来
        * 页表存储信息包括：是否已分配、超级权限、可读、可写、可执行

* 异常控制流
    > 控制流：指令的控制转移序列  
    > 异常控制流：对内部程序变量无法捕获的系统状态变化做出反应而发生的控制流突变
    * 异常类型：
        * 中断（异步）
        * 陷入（同步）
        * 故障（同步）
        * 终止（同步）
    * 异常处理：
        * CPU发生异常控制流
        * 通过“异常表基址寄存器”访问“异常表”
        * 执行当前“异常号”对应的“异常处理程序”
    * 内核模式与用户模式
        * 由某个寄存器的模式位表示
        * 处于内核模式的进程可以执行指令集中的任何指令，访问系统中任何内存位置
        * 用户模式使用用户栈，内核模式使用内核栈
        * 从用户模式变为内核模式的唯一方法就是通过异常控制流
    * 进程/线程上下文切换
        * 线程是调度的基本单位，进程是资源分配的基本单位
        * 切换寄存器中的值，特别是PC状态
        * 切换页表基址寄存器中的值，即切换整个虚拟地址空间，导致大量高速缓存失效

* 进程状态
    * (R)运行           ：该进程在调度队列中
    * (S)可中断睡眠     ：该进程在响应事件等待队列中
    * (D)不可中断睡眠   ：该进程不响应异步信号以保护控制流不被打断
    * (T)停止或跟踪     ：该进程被暂停或不能响应SIGCONT的跟踪状态
    * (X)退出           ：该进程即将退出
    * (Z)僵尸           ：该进程已经终止但还未被父进程回收，保留了内核栈、task、thread_info

## 网络
* 三次握手的原理
    * 防止旧的重复连接的初始化（旧SYN先到，响应RST）
    * 避免资源浪费（网络延迟而发送多个SYN包，建立多个连接）
    * 同步双方的初始序列号

* SYN泛洪攻击：发送大量合法的SYN包试图建立连接而无后续操作，占用服务器资源
    * 减少半连接状态持续时间
    * 设置最大半连接数量
    * 攻击者黑名单
    * SYN cookie（四元组+秘密数 hash）

* 四次挥手的原理
    * 全双工连接，两次握手关闭一个方向
    * 一个方向关闭后，另一个方向可能还有数据需要传输

* TIME_WAIT状态原理
    * 主动发起关闭连接的一方最后所进入会进入TIME_WAIT状态
    * 防止具有相同四元组的旧的数据包被新连接错误地接收，等待2MSL让原来连接的数据包全部过期
    * 等待足够的时间以确保最后的ACK能让对方接收从而正常关闭连接

* TIME_WAIT危害
    * 占用内存资源
    * 占用端口资源

* 出现大量TIME_WAIT原因
    * 服务器大量负载导致主动关闭大量连接
    * 客户端发起大量短连接

* 解决大量TIME_WAIT方案
    * 开启`tcp_timestamps`功能，从而在TCP报头中加入时间戳，根据时间戳来判断数据包是否过期从而可以不用等待2MSL
        同时开启下述参数：
    * 客户端开启`tcp_tw_reuse`，调用connect()时可重用一个TIME_WAIT持续超过1秒的端口
    * 服务器开启`tcp_tw_recyle`，快速重用socket，但是注意无法保证NAT后端的主机时钟同步，
        导致如果新连接中NAT服务器后端的主机时钟过慢而错判其时间戳为旧连接的数据包

* 流式数据导致粘包
    * 接受方：不及时处理
        * 后台线程预处理
        * 格式化头部信息
    * 发送放：等待缓冲区满
        * TCP紧急传送指令
        * 格式化头部信息


* 可靠数据传输：使数据按序、无缺失、不重复、信息完整地到达等对方
```python
##############################
# 发送方
##############################
维护核心变量：
下个数据段的序列号 seq
最早的已发送且未被确认的数据段的序列号 base

if 从应用层接收到数据:   # 事件一
    if 未启动定时器:
        则启动定时器
    将数据分片封装MSS
    计算下个数据段的序列号

if 接受到ACK报文:       # 事件二
    if ACK报文的序号 > base:
        更新base
        if 所有已发送数据段均已被确认:
            重启定时器
    elif 如果接受到3次冗余ACK:
        立即回传冗余ACK期望的数据段

if 定时器超时:          # 事件三
    超时间隔 *= 2
    重启定时器

##############################
# 接受方
##############################
if 接受到期望序号报文且之前数据均已确认:
    延迟回传ACK，最多延迟500 ms

elif 接受到期望序号报文且另一个报文等待确认:
    立即回传ACK累积确认两个报文

elif 接受到可以填充数据缺失间隙的报文:
    立即回传ACK累积确认

elif 比期望序号大的报文到达（数据缺失）:
    立即回传ACK指定期望序号

elif 比期望序号小的报文到达（数据冗余）:
    丢弃数据

elif 校验报文数据损坏且无法修复:
    丢弃数据
    立即回传ACK指定期望序号
```

* 拥塞控制：根据当前网络状况调整数据传输速率，从而改善整个网络环境
    * 控制已发送但未被接收的数据量不仅要小于对方接收窗口大小，同时还要小于拥塞窗口大小，通过控制拥塞窗口大小从而达到限流的目的
    * 初始拥塞窗口大小为1×MSS，进入慢启动状态
    * 慢启动状态：
        * 特点：拥塞窗口大小呈指数增长
        * 转移：当计时器超时时进入，并设置拥塞窗口大小为当前的一半，设置拥塞窗口为1MSS
    * 拥塞避免状态：
        * 特点：拥塞窗口大小呈线性增长
        * 转移：当速度达到慢启动阀值，或退出快速重传时进入
    * 快速重传状态：
        * 特点：初始速度为慢启动阀值，没接收一个冗余ACK就增大一个MSS
        * 转移：当连续接收3个冗余ACK时进入，并设置拥塞窗口大小为当前的一半
        * 转移：当接收到新ACK时进入拥塞避免状态，并设置拥塞窗口为慢启动阀值

* 请求web页面流程
    * **DHCP**：
        * 发起DHCP发现报文
        * DHCP主机回传DHCP响应
        * 此时可能有多个主机响应，选择其中一个发送DHCP请求
        * DHCP主机回传DHCP接收
        * 最后得到本机IP和子网掩码、DNS服务器IP、默认网关IP
    * **DNS**：
        * 请求DNS服务器解析目标域名，获取对应IP
        * 本地DNS服务器递归查询，其他网络中的DNS服务器一般都迭代查询
        * 获取的可能是目标域名的对应IP，也可能是目标域名所属的DNS服务器，后者就需要我们进行迭代查询
        * 得益于DNS缓存机制使得可以跳过大量的DNS服务器（诸如根DNS、顶级DNS等等），而且DNS使用UPD协议使查询速度更快
    * **应用层**：
        * 有了目的IP，就可以利用TCP套接字建立连接，然后进行网络间的进程间通讯(IPC)
    * **传输层**：
        * TCP协议会提供一些额外服务：三次握手简历全双工连接、可靠数据传输、拥塞控制等等
        * 将数据分片，每片最大MSS（MTU减去TCP/IP报头长度）
        * 添加TCP报头（包括源端口、目的端口、序列号等等）
    * **网络层**：
        * 查询路由表，把目的IP地址与路由表条目的掩码进行与运算，判断是否与该条目网段匹配，
            从而确定目的IP的下一跳地址（直接发送or通过网关），
            以及到达下一条地址需要从哪个网卡发送，从而确定源IP地址
        * 添加IP报头（包括源IP、目的IP等等）
    * **链路层**：
        * 此时处于网卡驱动程序，检查目的IP是否为本网卡IP，若是则直接回传到网络层（Docker虚拟网桥就是在这层捕获发送到容器中的数据包）
        * 查询arp表确定下一跳IP地址的MAC地址（如果没有则发送arp请求报文）
        * 添加MAC报头（包括源MAC、目的MAC地址等等）
    * **物理层**：
        * 此时处于网卡，进行信号转换

* 内容分发网络(CDN)
    * 单一数据中心缺点：
        * 数据中心到用户之间的距离太远从而延迟太高
        * 相同的数据多次通过相同的链路从而造成浪费
        * 单点故障后服务就会停止
    * 利用DNS服务将客户端请求重定向到一个适当的分布式集群（缓存）

* SSL协议
    > 主要功能：加密通讯  
    > 可选功能：端点鉴别（数字证书）、密钥交换算法（服务器证书或DH算法）
    * `C->`传送：提供加密算法列表、随机数1等等
    * `<-S`传送：选择一套加密算法、随机数2等等
    * `<-S`传送：（可选）服务器证书
    * `<-S`传送：（可选）DH算法参数
    * `<-S`传送：（可选）客户端证书请求
    * `C->`传送：利用随机数计算的PMS的密文（服务器公钥加密或DH算法加密）
    * `C->`传送：（可选）客户端证书
    * `C->`传送：（可选）DH算法参数
    * `C-S`操作：双方由PMS计算出MS，再生成2个对称密码与2个MAC密码，每个方向使用一对密码进行信息对称加密与信息完整性校验
    * `C->`传送：所有握手消息的MAC
    * `<-S`传送：所有握手消息的MAC

* RUDP协议
    * ROT翻倍 vs ROT不翻倍
    * 延迟ACK vs 非延迟ACK
    * 非退让控流（取消拥塞控制机制）

## 数据库

## 数据结构
* 二叉搜索树
    * 每个节点有两个子节点，父节点的值小于左子节点，大于右子节点
    * 特点：树的深度平均为log(N)，使得搜索操作的时间复杂度平均为log(N)，加快搜索速度的同时可以对数据进行排序
    * 缺点：但最坏的输入情况（所有数据已排序）会使二叉树退化为链表
* AVL树
    * 每个节点保持左子树与右子树高度差绝对值不超过1，每个节点额外记录树的高度
    * 若某次插入造成一个最深的节点的平衡因子绝对值大于1则进行旋转，从而恢复该子树的高度
    * 旋转大致分四种情况：
        * 如果插入左子节点的左子树或右子节点的右子树造成不平衡，则进行单旋转（画图）
            > Y不可能与X同水平，否则在插入之前便不平衡了；Y也不能与Z同水平，否则最深节点就应该是k1
        * 如果插入左子节点的右子树或右子节点的左子树造成不平衡，则进行双旋转（画图）
    * 缺点：平衡要求太严格，频繁地插入与删除导致频繁的旋转操作，开销太大
* 红黑树
    * 每个节点要么红色要么黑色
    * 根节点为黑色
    * 红色节点的子节点必须是黑色
    * 从一个节点到一个null指针的每一条路径必须包含相同数目的黑色节点
    * 特点：红黑树的高度最多是2log(N+1)，相对AVL树是在树的高度平衡与增删操作性能之间的折衷
* B+树
    * M叉搜索树
    * 非叶节点包含多个键值和指针，搜索时根据键值范围区间获取下个节点的指针
    * 除了根外，所有非叶节点的儿子数在M/2与M之间，防止M叉树退化
    * 数据只存储在叶节点上，所有叶节点都在相同深度上，且数据项个数在L/2到L之间（页分裂）
    * 特点：相对CPU密集型，IO密集型的程序的性能瓶颈在于磁盘IO的速度，
        利用B+树大大降低了树的深度（平均$log_{M/2}N$），
        也就大大减少了节点访问次数，从而减少了IO次数，最终提高了程序性能

* 散列表
    * 利用散列函数将键值映射到数组下标
    * 哈希冲突：
        * 分离链表法：将哈希到同一个下标的元素保存到一个链表中，相同元素放到一起，新插入的放前面（最近插入的一般会在最近再次访问）
        * 线性探测：哈希冲突使寻找下一个空闲位置存放元素，缺点是开销较大，而且会形成一次聚集
        * 平方探测：当表不为空时也可能找不到合适的位置插入，保证表大小为合数可以一定程度上降低这种事情发生的概率
        * 双散列：性能开销较大
    * rehash
        * 当填充因子过大时会重新分配内存，并将元素重新插入到新哈希表中；默认最大填充因子为0.75
