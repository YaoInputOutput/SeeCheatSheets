# 自我介绍
面试官您好，我是来自天津工业大学22届的本科学生，我叫熊海成。

可能您看到我的简历会比较好奇我的本科专业，对，没错，我的本科专业就是大名鼎鼎的四大天坑之一——材料。
当年添志愿的时候本来计算机是排在最前面的，结果阴差阳错地又把材料调到了前面，
后来又发生了一系列的事情触动了我，最后决定自学计算机，然后就这样一步步的靠自己走到现在，
接触了C++、接触了Linux、接触了开源社区。
这期间锻炼了我很多能力，特别是独立思考与学习的能力、解决问题和沟通的能力；
也学到了很多知识，像C++、Linux、MySQL、Docker等等，
特别是计算机的基础知识，因为我自己非科班嘛，所有我特别重视基础，这样我以后才能有更好发展潜力。
嗯，以上大概就是我想说的关于自我的介绍。

> 可能您看到我的简历会比较好奇我我专业。嗯，没错，我的专业就是传说中的四大天坑之一——材料。
> 本来当初添志愿的时候，计算机是排在材料前面的，结果阴差阳错地后来又调到了材料后面。
> 唉，不是当年复联三上映吗，看见钢铁侠的纳米战衣真的是帅炸的，这就是材料的力量吗？
> 年轻不懂事，就调了一下志愿，诶，就像当初投简历的时候，调了一下意向部门。
> 结果就这样，蝴蝶效应，一步步走上自学计算机之路，一路上全都靠自己思考，自己领悟，
> 然后接触Linux，接触开源社区，接触整个圈子，然后，现在坐在这儿来面试我最喜欢的天美。

**STAR法则**

问题：请讲出一件你通过学习尽快胜任新的工作任务的事。追问：
1. 这件事发生在什么时候？                       ———————S
2. 你要从事的工作任务是什么？                   ———————T
3. 接到任务后你怎么办？                         ———————A
4. 你用了多长时间获得完成该任务所必须的知识？   ———————深层次了解
5. 你在这个过程中遇见困难了吗？                 ———————顺便了解坚韧性
6. 你最后完成任务的情况如何？                   ———————R


# 项目
## SeeCheatSheets
这个项目本来的目的是作为一个我个人学习笔记仓库，囊括了我个人所学的绝大多数知识与技能，
仓库里一共包含了30多篇用markdown撰写的文章笔记，总计40多万字，都是我的知识结晶。
项目的目的本来是为了整理自己所学的知识，相当与一个思维导图，让我可以很方便的随时复习，加深印象。

> 这相当于是费曼学习法吧，每次写文章作笔记都是一个与自己对话的过程，给自己讲解每一个知识点，
> 最后将知识吸收变为自己的理解然后记录都文章里。

后来呢，因为项目里有许多记忆性的知识，比如C++标准库、POSIX API、Linux命令参数等等；
虽然这些大多都记得，我有刻意的去背、去记忆这些，但总有时候还是需要查询。

为了方便快速查询这些笔记，我用C++编写构建了一支程序，
可以根据关键字快速地搜索笔记片段并利用ANSI转义序列对markdown文本进行语法解析并高亮。
因为我平时学习和生产环境都是在终端命令行里进行的，所以查询结果直接在终端打印出来，很方便。
如果文本显示超出屏幕宽度还会将结果通过管道送给pager程序显示。
项目的github主页上展示了有效果图。

技术上的特点话，主要就是围绕“可扩展性”进行设计；
因为markdown本身语法由许多语法区块构成，比如列表区块、引用区块、代码区块等等；
而且，不同版本的markdown语法都有各自独特的语法元素，比如比较流行github风味的版本就支持@用户和提及issue等等，
markdown的作者都没有官方地统一标准，所有很有必要去思考如何提高程序的可扩展性；

我的设计上呢，首先就是为不同的语法模块设计一个抽象基类，这个抽象基类的接口大致有3个：
* 第一个方法用于判断当前行是否为某语法区块的开头
* 第二个方法用于判断当前行是否为某语法区块的结尾
* 第三个方法就是对开头到结尾之间的文本内容进行语法解析并高亮

但这儿有个问题就是，一个类型的语法模块可能依赖于另一个类型的语法模块；
比如说，判断是否结束“列表区块”就依赖于当前行是否是引用区块的开头、代码区块的开头等等，
还有比如，大多数语法区块都依赖“解析普通段落的语法区块”，用它的语法高亮方法来解析部分内容；

如果各个语法模块之间直接相互引用的话，将类型信息硬编码进代码中，
就会导致模块间非常高的耦合度，从而导致各个模块没法独立的变换扩展，
只要对一个模块进行修改扩展，就要同时修改其他所有依赖它的模块；
这时候为了降低各个语法模块间直接相互引用而导致的耦合，就需要引入“中介者模式”；

首先我需要设计一个中介者类，所有属于同一个markdown语法版本的语法模块都向同一个中介者注册自身，
各个语法模块与其他语法模块间的相互调用都需要通过中介者来进行，
这样每个语法模块都可以独立的修改扩展而不影响到其他模块，
实现上就是在中介者内部用哈希表键值对来存储各语法模块的指针，
注册时，比如列表区块就注册键值为list，引用区块就注册键值为quote等等；

同时，因为中介者聚集封装了各个语法模块而形成一个用于完整Markdown语法模块，
这样中介者去除也算是一个表观模式中的表观类吧；
很自然的，我只需要一个中介者，所以又将这个中介者设计成单例模式；

除此之外，还有一个特点是，语法模块的抽象基类的构造函数比较特殊，
所有派生自它的子类在构造其对象实例时都自动地向中介者单例注册自身；

这样设计下来，每当我们要设计添加一个语法高亮模块时，
* 就先派生自抽象基类，
* 然后实现基类接口，
* 最后定义一个静态变量；

当程序启动后，在调用main函数之前，会先调用静态变量的构造函数，
这样就会调用基类的构造函数，然后自动地向中介者单例注册那些引入的语法模块。
而语法模块的设计分为两部分，两个文件，
* 一个是头文件，里面有派生类的定义，以及该派生类的一个inline的静态变量，
* 另一个是实现文件，就是实现了头文件中的接口。

这样，只要在主模块文件中include语法模块的头文件，就相当于自动引入了该语法模块。
想要修改Markdown版本，实现新的语法模块，然后引入新的头文件就行了。

这个设计最大的问题在于，引入的头文件模块都自动的向一个中介者注册自身，
所以运行时只能同时存在一个Markdown语法版本，这对于我自己来说是可接受的，而且这种设计更方便也更有趣；

如果正常设计的话，就老老实实地在中介者的构造函数中手动注册各个版本的语法模块，形成完整的markdown语法模块。
不同版本的markdown语法就只要将各个版本的语法模块组装起来就行了。

大概设计架构就是这样，剩下的就是语法解析算法的实现了。
解析算法上比较特殊的就是标题区块与代码区块的语法解析吧，
这两个语法模块解析都需要获取终端窗口大小，这就需要调用Posix标准的系统api来获取，
同时也需要计算每一行字符的显示宽度，这就涉及到了简历上第四个项目了。
最后的话，就是普通段落区块的解析算法比较麻烦，需要用栈来记录行内emphasize元素的开启与关闭，
比如斜体粗体呀、内联代码、下划线等等，关闭的时候需要结束当前元素颜色显示，同时恢复外层元素的颜色显示。

* 问：如何实现在基类构造函数中注册派生类实例？
* 答：这就涉及到C++的多态原理。派生类的数据成员其实可看作两部分，一个是派生类部分，一个是基类部分。
如果类中定义了有虚函数，就会引入一个隐式的数据成员——虚指针，虚指针指向虚表，
虚表里存储了虚指针所在类的运行时的真实类型信息，以及该运行时类型的虚函数入口地址；
派生类部分与基类部分都有虚指针，所以我们基类的this指针就相当于把派生类的指针转换为基类指针，从而形成多态，
然后通过指针调用虚函数时，就会根据指针找到虚表，然后找到相应的虚函数入口地址，这个过程就是动态绑定。


## DotFiles
这个项目其实也没啥说的，就是作为两年多的Linux用户、Linux的热爱者，我自己所积累下来的整个开发环境的配置。
项目里提供了一个Shell脚本，可完整的还原我自己的整个开发环境，方便我重装，
俗称“折腾”嘛，linux用户都挺爱折腾的。
折腾的过程中我们得不断的去思考，
不断地去发现问题、定位问题、搜索解决方案、尝试自己解决，经常会引发我自己去思考一些底层的设计原理。
这确实是很锻炼一个人的独立思考能力、解决问题的能力和意志力。
折腾了两年下来，其实更重要的是这个过程而非结果。这个项目也是记录了我个人的成长过程吧。

比如国内DNS污染问题，我经常访问github会受到域名污染的问题，特别是校园网。
一开始我不知道域名污染，我想应该不止我一个人访问github很慢吧，我就去搜“github访问很慢怎么办”？
结果就知道了，哦，是域名污染的原因，根据我学的计算机网络的知识，知道DNS在网络中扮演什么样的角色，
也就明白为什么改hosts文件会有效果。

后来不满改hosts的方法非常麻烦，特别是对于github博客的域名，就是github.io，每个博客的域名都是不一样的，
所以没法通过修改hosts文件来解决，于是我就想，有没有其他方法从根上解决域名污染呢？
诶，我就想到直接用github的权威DNS服务器，这样就不会有域名污染的问题了吧。
实验倒是成功了，但是速度有点感人，太慢了。
然后我就想，能不能只对github的域名使用他家权威DNS服务器，就是对于指定的域名使用指定的DNS服务器来解析。
然后我就去搜，在stackoverflow上找到了答案，说是linux内核并不支持这样做，需要自己搭建DNS服务器。
然后就顺藤摸瓜，去修改NetworkManager服务的配置，让NetworkManager将DHCP获取的DNS服务器IP写到另一个文件中去，
而将resolv.conf中的本地使用的DNS服务器地址改为本地回环地址，
然后手动通过systemd启动dnsmasq服务，然后让dnsmasq自动读取之前NetworkManager写入的本地DNS的IP地址，
作为默认的DNS服务器，然后配置当解析github的域名的时候使用github自己的DNS服务器

chfs、systemd、转发、SELinux、FreeDesktop

字体合成、终端、字体矢量图、字体回滚、搜索解决方法

就像这样，问题一个一个得被解决，配置越来越多，开发环境越来越舒服。
所以这个项目对我来说，是一个我成长的过程吧。

## SpaceVim
SpaceVim是一个社区驱动开发的模块化的vim发行版，它利用模块的形式来管理插件集合。
SpaceVim在2018年立项，我也在立项不久就接触SpaceVim。
当年vim配置那是群魔乱舞，百花齐放，现在有了SpaceVim其实很大程度上改善了这一状况，
因为在大多竞品当中，SpaceVim是社区最庞大，开发最活跃，功能最完善，文档最齐全的。
很大程度降低了vim的门槛，对新手更加友好。
上游维护者还希望我们在高校中推广SpaceVim，当然我都去推广我自己的fork分支版本了。

项目中模块化管理确实是一个非常棒的设计，如今SpaceVim有这么多包括我在内的贡献者其实模块化设计作了很大贡献。

我作为一个开源贡献者，累计提交了共3个PR，共修复了2个bug和1个特性增强；
1个bug是关于文件内容匹配搜索的大小写敏感问题，1个是关于上游插件更新接口导致的兼容性问题；
增强的特性是对一些插件的加载规则进行修改再加以测试，提高加载速度的同时保证用户的对此的透明性。

虽然贡献的不多，但我对于我自己的fork分支版本进行了大量的修改。
总共修改了有40多个源文件，累计修改了将近4000行源代码，同时还写了有比较完善的使用文档。

作为开源贡献者，同时也是SpaceVim社区中的一员，经常会参与讨论一些项目相关话题，
我想这也是会块源社区做贡献的一种方式。

有时会有新手问vim本身的如何去配置，我一般看到都会耐心跟他们讲解vim的各种概念和功能特性；

有时会交流一些技术问题，比如向他们学到的，通过适时检测vim的窗口布局来实现让一些辅助窗口不影响vim退出；

有时我也会提出一些我自己的设计，比如给快速运行插件添加个功能，通过匹配文件内容来自动添加一些参数，
比如我在C++中引入并发相关的头文件，就自动添加编译器参数`-lpthread`链接linux线程库，
还有用C重写计时器，可以计时更精准，我还可以添加功能来获取程序的退出码和中断信号。

团队合作中，沟通其实非常重要。

而且这也是我第一次大规模的阅读别人的代码，其实还是很有挑战的。


我就说说我自己作了哪些修改吧：
* * * * * * * * * *
* **图标**：基于文件名、基于vim内建类型
* * * * * * * * * *
* **自动补全**：语义补全引擎与结对符补全，issue，实现
* * * * * * * * * *
* **语法检测**：cppcheck、clangtidy
* * * * * * * * * *
* **颜色主题**：针对C++
* * * * * * * * * *
* **字符画**：独角兽、不可描述
* * * * * * * * * *
* **状态栏**：算法修改，根据当前窗口宽度来选择展示的内容，行列号
* * * * * * * * * *
* **Fcitx与Fcitx5**：四种状态、问过上游
* * * * * * * * * *
* **FlyGrep文件内容搜索**：大小写敏感，PR
* * * * * * * * * *
* **QuickRun快速代码运行**：替代上游
    * 内建终端（方便）
    * 计时器（Linux api、更精准、派生子进程、前台进程组、信号、返回码、中断信号）
    * CGroup限制内存使用
    * 自动检测时间戳
    * 窗口隔离
    * 参数设置（设置编译器参数、运行命令、IO重定向）
    * 无伤移植
* * * * * * * * * *
* **文件树**：绑定快捷键到GUI程序
* * * * * * * * * *
* **tmux**：交互
* * * * * * * * * *
* **C模块**：三个插件（语义补全引擎、语法检测引擎、我的代码快速运行插件）统一C++标准版本。
* * * * * * * * * *
* **文档**：精简齐全，不用过脑
* * * * * * * * * *


> 但是由于整个项目基本上都是使用vim自带的脚本实现的，我自己对vim的各个api函数不太了解，
> 所以经常需要边修改边去查阅文档，现学现卖，甚至有些时候还要和上游维护者交流一下，向它们请教一下。
> 项目的维护者们建了有在线聊天室，经常有问题就会在聊天室里提出来，商量解决方案。
> 当需要正式修改的时候就要走在流程，先提issue，再提pr，最后review合并。
> 因为我经常在群里发言，他们就注意到了我自己fork的分支版本，觉得很不错，说我要是觉得有什么特性可以合并的提pr就行。

整个项目对我而言，其实是对我自身综合能力的锻炼吧，毕竟这么大个项目，团队合作很重要。
而且这也是我自身第一次大量的阅读别人的源码，而且还是自己没熟练掌握的语言，
所以对我而言，需要大量的思考别人的设计，才能修改成我想要的样子。


# 技术反问
* 项目组里C++标准大概都是用的哪版？
* 项目组里的工作内容？
* 需要我补充哪方面的知识或者锻炼哪方面能力呢？


# HR谈薪
* 问：期望薪资？
* 答：就技术面试官对我的评价以及您的经验来看，贵司应该能给到多少？
* 答2：
    * 参考对方公司公开薪资表
    * 参考上份工作×130%左右
    * 面试效果好就报高点，不好则报低点
    * 尽量把合同上的薪资谈高（月薪）


* 在 hr 面自己也可以问一问公司的一些情况，比如
    * 薪资结构
    * 年终奖
    * 五险一金
    * 加班情况
    * 加班费计算
    * 升职加薪的规章制度
    * 年假安排等

* 注意，技术面试官谈薪资时，答：“现在还不确定，HR需要综合评定。”（无法回避就报低点）


# 八股整理
## 操作系统
* 加法器
    * c1 = A & B
    * s1 = A ^ B
    * c2 = s1 & c
    * s2 = s1 ^ c
    * s  = s2
    * c  = c1 ^ c2

* 减法器
    * x - y
        = x + 1111 - y + 1 - 10000
        = x + ~y + 1
    * -y = ~y + 1

* 整形编码
    * 无符码与补码
    * 扩展、截断、转换
    * 求逆、加法、乘法

* 浮点数编码
    * 符号-阶码-尾数
    * 非规格化（正负0）、规格化、无穷、NaN
    * 精度：无结合律、近似比较

* 寄存器类型
    * PC
    * 通用
    * 浮点
    * 标识

* 进程内存布局（从低地址到高地址）
    * 代码段：ELF中的.text与.rodata区
        > .text保存机器指令，.rodata保存诸如字符串字面量与浮点数字面量；
        > x86指令浮点数没有立即数，所以需要存储到.rodata；而整数有立即数，可以直接存储到机器指令中
    * 数据段：ELF中的.data与.bss区
        > .data保存全局和静态变量，.bss保存为初始化或初始化为0的全局和静态变量，
        > 为节省空间，.bss中的变量只记录符号名而不分配空间，在加载时才分配内存并初始化为0
    * 堆：
        > 就是我们new表达式申请的内存空间，C++语言的内存分配器帮我们管理这片空间，
        > 可以进行内存分配、碎片整理、垃圾回收等等
    * 共享段：
        > 调用动态共享库时会将动态库的代码段和数据段映射到这里
    * 栈：
        > 保存运行时数据
    * 内核保留空间：起始于$2^48$
        * 内核代码与数据
        * 物理内存映射
        * 当前进程专属信息（页表、段表、内核栈等等）

* 运行时栈
    * 函数参数
    * 返回地址
    * 被调用者保留寄存器值
    * 局部变量
        * 结构与数组
        * 取地址的变量
        * 寄存器不足

* 对抗缓冲区溢出攻击
    * 地址空间布局随机化(ASLR)
        > 运行时随机设置关键区域的地址空间，同时保证堆、共享段、栈的相对地址不变；
        > 随机化范围大约$2^32$，“空操作雪橇”暴力破解
    * 栈破坏检测
        > 在返回地址前面设置运行时随机的“金丝雀值”，并将该值放在只读寄存器中，函数返回前检测
    * 限制可执行代码区域

* 静态链接
    * 符号解析：将多个目标文件中的符号定义与符号引用绑定起来
        > 实现上维护三个集合：未绑定引用集合、定义集合、文件集合。链接器依次解析命令行参数文件
    * 重定位：将多个目标文件聚合成一个文件后，一些引用地址需要修改
        > 外部函数、内部全局变量、外部全局变量；
        > 内部函数(相对地址不变)

* 动态链接
    * 编译时：提取动态库符号信息
    * 启动时：调用链接器加载动态库
        > 动态库搜索路径：
        1. 可执行文件中指定
        2. 环境变量LD_LIBRARY_PATH指定
        3. 配置文件/etc/ld.so.cache指定
        4. 系统默认路径/lib
    * 内存映射：代码段母本、数据段副本（相对代码段位置不变）、位置无关代码（无需重定位）
    * 变量引用：立即绑定到GOT表
    * 函数引用：延迟绑定到PLT表

* 虚拟内存
    * 优点：
        * 使系统更高效地利用内存
            * 进程看起来连续的地址空间页面，实际上可能被分散地映射到了物理内存各处，系统可以很好的利用一些空间碎片
            * 进程的虚拟地址空间是可以映射到磁盘空间的，
                系统利用LRU算法会在内存紧张的时候将一些不常用的页面冲刷到磁盘swap空间，下次访问时再加载回来
        * 简化内存管理：
            * 为每个进程提供一致的地址空间，可以简化链接、简化加载、简化共享、简化内存分配
        * 内存保护机制：
            * 每个进程的地址空间都相对独立，从而避免地址空间被其它进程破坏
            * 每个页面都有一些标识位：超级权限、可读、可写、可执行
    * 地址翻译：
        * 当CPU指令进行访存操作时，先将虚拟地址送给MMU进行翻译
        * 将虚拟地址分为两部分：虚拟页号与偏移量
        * 然后从页表基址寄存器读取页表起始地址访问页表（页表有单独的高速缓存TLB）
        * 根据页表进行索引，找到对应的物理页号；同时根据偏移量去高速缓存中找出可能的数据
        * 当翻译完成后检查提前找出的数据地址是否匹配，如果匹配就加速的数据访问，若不匹配则通过物理地址重新访问高速缓存
    * 页与段：
        * 页是内存分配的基本单位，段将连续的功能相同的页组织关联起来
        * 页表存储信息包括：是否已分配、超级权限、可读、可写、可执行

* 异常控制流
    > 控制流：指令的控制转移序列  
    > 异常控制流：对内部程序变量无法捕获的系统状态变化做出反应而发生的控制流突变
    * 异常类型：
        * 中断（异步）
        * 陷入（同步）
        * 故障（同步）
        * 终止（同步）
    * 异常处理：
        * 通过“异常表基址寄存器”访问“异常表”
        * 执行当前“异常号”对应的“异常处理程序”
    * 内核模式与用户模式
        * 由某个寄存器的模式位表示
        * 处于内核模式的进程可以执行指令集中的任何指令，访问系统中任何内存位置
        * 用户模式使用用户栈，内核模式使用内核栈
        * 从用户模式变为内核模式的唯一方法就是通过异常控制流
    * 进程/线程上下文切换
        * 线程是调度的基本单位，进程是资源分配的基本单位
        * 保存寄存器中的值，保证后来能正常运行线程被调度前的下条指令
        * 切换页表基址寄存器中的值，即切换整个虚拟地址空间，导致TLB大量缓存失效

* 进程状态
    * (R)运行           ：该进程在调度队列中
    * (S)可中断睡眠     ：该进程在响应事件等待队列中
    * (D)不可中断睡眠   ：该进程不响应异步信号以保护控制流不被打断
    * (T)停止或跟踪     ：该进程被暂停或不能响应SIGCONT的跟踪状态
    * (X)退出           ：该进程即将退出
    * (Z)僵尸           ：该进程已经终止但还未被父进程回收
