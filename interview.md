# 自我介绍
面试官您好，我是来自天津工业大学22届的本科学生，我叫熊海成。

可能您看到我的简历会比较好奇我的本科专业，对，没错，我的本科专业就是大名鼎鼎的四大天坑之一——材料。
当年添志愿的时候本来计算机是排在材料前面的，结果因为一些原因就又把材料调到前面去了，
后来又发生了一系列的事情触动了我的心灵，最后促使我决定自学计算机，然后就这样一步步的靠自己独立学习、独立思考走到现在，
接触了C++、接触了Linux、接触了开源社区和开源理念，接触整个计算机世界，真得是大开我的眼界。
这期间锻炼了我很多能力，也学到了很多知识，像C++、Linux、MySQL、Docker等等，
特别是计算机的基础知识，因为我自己非科班嘛，所有我特别重视基础，这样我以后才能有更好发展潜力。
嗯，以上大概就是我想说的关于自我的介绍。

> 可能您看到我的简历会比较好奇我我专业。嗯，没错，我的专业就是传说中的四大天坑之一——材料。
> 本来当初添志愿的时候，计算机是排在材料前面的，结果阴差阳错地后来又调到了材料后面。
> 唉，不是当年复联三上映吗，看见钢铁侠的纳米战衣真的是帅炸的，这就是材料的力量吗？
> 年轻不懂事，就调了一下志愿，诶，就像当初投简历的时候，调了一下意向部门。
> 结果就这样，蝴蝶效应，一步步走上自学计算机之路，一路上全都靠自己思考，自己领悟，
> 然后接触Linux，接触开源社区，接触整个圈子，然后，现在坐在这儿来面试我最喜欢的天美。

# 项目
## SeeCheatSheets
这个项目囊括了我个人所学的绝大多数知识与技能，
> 包括，比如C++、Linux、Python、MySQL、Docker以及计算机基础知识、底层知识等等；
仓库里一共包含了31篇用markdown撰写的文章笔记，总计14000行，48万字，都是我的知识结晶。
项目的目的本来是为了整理自己所学的知识，相当与一个思维导图，让我可以很方便的随时复习，加深印象。

> 这相当于是费曼学习法吧，每次写文章作笔记都是一个与自己对话的过程，给自己讲解每一个知识点，
> 最后将知识吸收变为自己的理解然后记录都文章里。

后来，添加了许多记忆性的知识，比如C++标准库、Unix系统接口、Linux命令参数等等；
虽然这些大多都记得，我有刻意的去背、去记忆这些，但总有时候还是需要查询。

为了方便快速查询这些笔记，我用C++编写构建了一支程序，
用于根据关键字地搜索笔记片段并利用ANSI escape序列对markdown文本进行语法解析并高亮。
因为我平时学习和生产环境都是在终端命令行里进行的，所以查询结果直接在终端打印出来，很方便。
如果文本显示超出屏幕宽度还会将文本通过管道送给pager程序显示。
项目的github主页上展示了有效果图。

技术上的特点话，主要就是围绕其可扩展性进行设计吧；
因为markdown本身语法由许多语法区块构成，比如列表区块、引用区块、代码区块等等；
而且，不同版本的markdown语法都有各自独特的语法元素，比如比较流行github风味的版本就支持@用户和提及issue等等，
markdown的作者都没有官方地统一标准，所有很有必要去思考如何提高程序的可扩展性；

我的设计上呢，首先就是为不同的语法模块设计一个抽象基类，这个抽象基类的接口大致有3个：
* 第一个方法用于判断当前行是否为某语法区块的开头
* 第二个方法用于判断当前行是否为某语法区块的结尾
* 第三个方法就是对当前语法区块中的文本进行语法解析并高亮

但这时候问题出现了，因为基于这个设计上，一个语法模块可能依赖于另一个类型的语法模块；
比如说，大多数语法块都依赖解析普通段落的语法块，用它进行部分的语法解析高亮，
还有比如判断是否结束列表语法区块就依赖于当前行是否是引用语法块的开头等等；
如果各个语法模块之间直接相互引用的话，会导致模块间非常高的耦合度，从而导致各个模块没法独立的变换扩展，
只要对一个模块进行修改扩展，就要同时修改其他所有依赖它的模块；
这时候为了降低各个语法模块间直接相互引用而导致的耦合，就需要引入中介者模式；

首先我需要设计一个中介者类，所有属于同一个markdown语法版本的语法模块都向同一个中介者注册自身，
各个语法模块与其他语法模块间的相互调用都需要通过中介者来进行，
这样每个语法模块都可以独立的修改扩展而不影响到其他模块，
实现上就是在中介者内部用哈希表键值对来存储各语法模块的指针，
注册时，比如列表区块就注册键值为list，引用区块就注册键值为quote等等；

同时，因为中介者聚集封装了各个语法模块而形成一个用于完整解析Markdown语法并高亮它的类，
这样中介者去除也算是一个表观模式中的表观类吧；

除此之外，还有一个特点是，我在语法模块的抽象基类的构造函数中做了手脚，
使得所有派生自它的子类在构造其对象实例时都自动地向中介者注册自身，这就需要在这之前有一个中介者实例对象；
为了实现这个功能，我将之前说的中介者类再加一层设计模式，把它设计成单例模式；
这样我们可以在基类构造函数中就直接向那个中介者单例注册自身，而用户也只能使用这个我们已经搭配好的单例；

这样设计下来，每当我们要设计添加一个语法高亮模块时，就先派生自抽象基类，然后实现基类接口，最后定义一个静态变量；
当程序启动后，在调用main函数之前，会先调用静态变量的构造函数，
这样就会调用基类的构造函数，然后自动地向中介者单例注册那些引入的语法模块。
而语法模块的设计分为两部分，两个文件，
一个是头文件，里面有派生类的定义，以及该派生类的一个inline的静态变量，
另一个是实现文件，就是实现了头文件中的接口。
这样，只要在主模块文件中include语法模块的头文件，就相当与引入了该语法模块。

这里有个问题就是，多文件编译时静态变量的构造顺序是未定义的，
也就是说如果我们用简单的全局变量来实现单例模式的话，语法模块类实例很可能会先于中介者单例构造的，
而语法模块的构造又需要向中介者单例注册，由此会产生错误。
这时候就需要reference-return技术来实现单例模式，
就是设计一个Instant()函数，函数内部定义有中介者类型的局部静态变量，然后函数返回这个局部静态变量。
函数局部静态变量在第一次调用函数时才会初始化，同时C++标准保证了函数局部静态变量的线程安全性；
这应该算是最简单的一种单例模式了吧；

大概设计架构就是这样，剩下的就是语法解析算法的实现了。
解析算法上比较特殊的就是标题区块与代码区块的语法解析吧，
这两个语法模块解析都需要获取终端窗口大小，这就需要调用Posix标准的系统api来获取，
同时也需要计算每一行字符的显示宽度，这就涉及到了简历上第四个项目了。
最后的话，就是普通段落区块的解析算法比较麻烦，需要用栈来记录行内emphasize元素的开启与关闭，
比如斜体粗体呀、内联代码、下划线等等，关闭的时候需要结束当前元素颜色显示，同时恢复外层元素的颜色显示。

* 问：如何实现在基类构造函数中注册派生类实例？
* 答：这就涉及到C++的多态原理。派生类的数据成员其实可看作两部分，一个是派生类部分，一个是基类部分。
如果类中定义了有虚函数，就会引入一个隐式的数据成员——虚指针，虚指针指向虚表，
虚表里存储了虚指针所在类的运行时的真实类型信息，以及该运行时类型的虚函数入口地址；
派生类部分与基类部分都有虚指针，所以我们基类的this指针就相当于把派生类的指针转换为基类指针，从而形成多态，
然后通过指针调用虚函数时，就会根据指针找到虚表，然后找到相应的虚函数入口地址，这个过程就是动态绑定。

* 问：为什么要将中介者设计成单例模式？
* 答：因为想要在基类构造函数中就实现注册派生类实例，就必须提前存在一个中介者实例，
如果用全局变量实现这个实例的话，用户很可能不会使用这个全局变量；
所以就用单例模式，这样开发者与用户都会使用相同的中介者。
当然这种设计会一定程度的降低可扩展性，因为语法模块内部都是直接引用的中介者，导致扩展中介者类时很麻烦。

当然，其实这也不算问题，因为扩展中介者类就意味着我们想要扩展不同的markdown语法版本。
我的设计上已经将各个语法模块都分离到单独的源文件中，并用头文件做接口桥梁。
这样一来，当我们想使用不同的markdown版本，就只需要引入不同版本对应的语法模块的头文件，进行排列组合即可。
只是这样一来，在运行时就只能有一个版本，但对我来说这是可接受的，毕竟这种设计很方便也很有趣。

如果正常设计的话，就老老实实地手动向中介者注册语法模块（比如在中介者的构造函数中），
然后对中介者类进行派生以适用于不同版本风味的markdown语法。

## DotFiles
这个项目其实也没啥说的，就是作为两年多的Linux用户、Linux的热爱者，我自己所积累下来的整个开发环境的配置。
项目里提供了一个Shell脚本，可完整的还原我自己的整个开发环境，方便我重装，
俗称“折腾”嘛，linux用户都挺爱折腾的。
折腾的过程中我们得不断的去思考，
不断地去发现问题、定位问题、搜索解决方案、尝试自己解决，经常会引发我自己去思考一些底层的设计原理。
这确实是很锻炼一个人的独立思考能力、解决问题的能力和意志力。
折腾了两年下来，其实更重要的是这个过程而非结果。这个项目也是记录了我个人的成长过程吧。

那我就挑几个我现在还记得的一些问题的解决吧。


比如国内DNS污染问题，我经常访问github会受到域名污染的问题，特别是校园网。
一开始我不知道域名污染，我想应该不止我一个人访问github很慢吧，我就去搜“github访问很慢怎么办”？
结果就知道了，哦，是域名污染的原因，根据我学的计算机网络的知识，知道DNS在网络中扮演什么样的角色，
也就明白为什么改hosts文件会有效果。

后来不满改hosts的方法非常麻烦，特别是对于github博客的域名，就是github.io，每个博客的域名都是不一样的，
所以没法通过修改hosts文件来解决，于是我就想，有没有其他方法从根上解决域名污染呢？
诶，我就想到直接用github的权威DNS服务器，这样就不会有域名污染的问题了吧。
实验倒是成功了，但是速度有点感人，太慢了。
然后我就想，能不能只对github的域名使用他家权威DNS服务器，就是对于指定的域名使用指定的DNS服务器来解析。
然后我就去搜，在stackoverflow上找到了答案，说是linux内核并不支持这样做，需要自己搭建DNS服务器。
然后就顺藤摸瓜，去修改NetworkManager服务的配置，让NetworkManager将DHCP获取的DNS服务器IP写到另一个文件中去，
而将resolv.conf中的本地使用的DNS服务器地址改为本地回环地址，
然后手动通过systemd启动dnsmasq服务，然后让dnsmasq自动读取之前NetworkManager写入的本地DNS的IP地址，
作为默认的DNS服务器，然后配置当解析github的域名的时候使用github自己的DNS服务器

chfs、systemd、转发、SELinux、FreeDesktop

字体合成、终端、字体矢量图、字体回滚、搜索解决方法

> 比如说git这个版本管理器，想要真正掌握git就必须去学习去思考它是如何设计的，为什么这样设计。
> git作为一个分布式版本管理系统，如果我们克隆仓库的时候不加额外的参数，
> 就会直接把所有的历史提交记录都克隆下来，作为一个全节点，只有网络中还存在一个项目克隆备份，就可以完整地恢复该项目。
> 而想要用git管理项目，管理提交历史，管理分支都需要我们去学习它的原理。
> git管理的历史数据其实有4大部分组成：
> * 第一个是对象，其实就是每个文件的修改提交后的全量备份，俗称“文件快照”
> * 第二个是树，树负责指向一系列对象，这些对象都是同属于某个历史节点的“文件快照”，由此组成整个项目在当前历史节点上的“快照”
> * 第三个是提交信息，包含了一颗树代表历史快照，还记录了一些关于历史节点的提交信息，比如提交者姓名、邮件、提交描述等等
> * 最后一个就是指针，指针指向一个提交信息，而实际上分支其实就是在历史节点上移动的指针
> 
> 知道了这些原理之后，我也就知道了整个项目的历史，其实就是一个个commit节点构成的一个存在分叉的链，
> 于是也就知道了，分支切换与历史回溯也就是将HEAD指针指向版本链上的某一节点，
> 也就知道了，分支合并其实就是对合并节点的树进行调整，合并的树会指向两分支的树所指向的对象的交集，
> 对于非交集部分的同名文件，会首先判断该对象是否只有其中一个分支相对两分支共同祖先进行了修改（添加和删除文件都没视作修改），
> 如果是则合并的树会指向修改的对象，如果两个分支都修改了，则中断合并过程，等待用户手动修复。

就像这样，问题一个一个得被解决，配置越来越多，开发环境越来越舒服。
所以这个项目对我来说，是一个我成长的过程吧。

## SpaceVim
SpaceVim是一个社区驱动开发的模块化的vim发行版，它利用模块的形式来管理插件集合。
SpaceVim在2018年立项，我也在2019年立项不久就接触SpaceVim。
当年vim配置那是群魔乱舞，百花齐放，现在有了SpaceVim其实很大程度上改善了这一状况，
因为在大多竞品当中，SpaceVim是社区最庞大，开发最活跃，功能最完善，文档最齐全的。
很大程度降低了vim的门槛，对新手更加友好。
上游维护者还希望我们在高校中推广SpaceVim，当然我都去推广我自己的fork分支版本了。

项目中模块化管理确实是一个非常棒的设计，如今SpaceVim有这么多包括我在内的贡献者其实模块化设计作了很大贡献。

我作为一个开源贡献者，累计提交了共3个PR，共修复了2个bug和1个特性增强；
1个bug是关于文件内容匹配搜索的大小写敏感问题，1个是关于上游插件更新接口导致的兼容性问题；
增强的特性是对一些插件的延迟加载加以测试，提高加载速度的同时保证用户的对此的透明性。

虽然贡献的不多，但我对于我自己的fork分支版本进行了大量的修改。
总共修改了有46个源文件，累计修改了将近4000行源代码，同时还写了有比较完善的使用文档。

不仅是作为开源贡献者，同时也是SpaceVim社区中的一员，经常会参与讨论一些项目相关话题，
我想这也是会块源社区做贡献的一种方式。

有时会有新手问vim本身的如何去配置，我一般看到都会耐心跟他们讲解，教他们去改配置、写vim脚本；

有时会交流一些技术问题，比如向他们学到的，通过适时检测vim的窗口布局来实现让一些辅助窗口不影响vim退出；

有时我也会提出一些我自己的设计，比如给快速运行插件添加个功能，通过匹配文件内容来自动添加一些参数，
比如我在C++中引入并发相关的头文件，就自动添加编译器参数`-lpthread`链接linux线程库，
还有用C重写计时器，可以计时更精准，我还可以添加功能来获取程序的退出码和中断信号。

团队合作中，沟通其实非常重要。

而且这也是我第一次大规模的阅读别人的代码，其实还是很有挑战的。


我就说说我自己作了哪些修改吧：
* * * * * * * * * *
* **图标**：基于文件名、基于vim内建类型
* * * * * * * * * *
* **自动补全**：语义补全引擎与结对符补全，issue，实现
* * * * * * * * * *
* **语法检测**：cppcheck、clangtidy
* * * * * * * * * *
* **颜色主题**：针对C++
* * * * * * * * * *
* **字符画**：独角兽、不可描述
* * * * * * * * * *
* **状态栏**：算法修改，根据当前窗口宽度来选择展示的内容，行列号
* * * * * * * * * *
* **Fcitx与Fcitx5**：四种状态、问过上游
* * * * * * * * * *
* **FlyGrep文件内容搜索**：大小写敏感，PR
* * * * * * * * * *
* **QuickRun快速代码运行**：替代上游
    * 内建终端（方便）
    * 计时器（Linux api、更精准、派生子进程、前台进程组、信号、返回码、中断信号）
    * CGroup限制内存使用
    * 自动检测时间戳
    * 窗口隔离
    * 参数设置（设置编译器参数、运行命令、IO重定向）
    * 无伤移植
* * * * * * * * * *
* **文件树**：绑定快捷键到GUI程序
* * * * * * * * * *
* **tmux**：交互
* * * * * * * * * *
* **C模块**：三个插件（语义补全引擎、语法检测引擎、我的代码快速运行插件）统一C++标准版本。
* * * * * * * * * *
* **文档**：精简齐全，不用过脑
* * * * * * * * * *


> 但是由于整个项目基本上都是使用vim自带的脚本实现的，我自己对vim的各个api函数不太了解，
> 所以经常需要边修改边去查阅文档，现学现卖，甚至有些时候还要和上游维护者交流一下，向它们请教一下。
> 项目的维护者们建了有在线聊天室，经常有问题就会在聊天室里提出来，商量解决方案。
> 当需要正式修改的时候就要走在流程，先提issue，再提pr，最后review合并。
> 因为我经常在群里发言，他们就注意到了我自己fork的分支版本，觉得很不错，说我要是觉得有什么特性可以合并的提pr就行。

整个项目对我而言，其实是对我自身综合能力的锻炼吧，毕竟这么大个项目，团队合作很重要。
而且这也是我自身第一次大量的阅读别人的源码，而且还是自己没熟练掌握的语言，
所以对我而言，需要大量的思考别人的设计，才能修改成我想要的样子。


# topK算法
| 数据结构 | 描述                                           | 动态/静态 |
|----------|------------------------------------------------|-----------|
| 数组     | 快速选择算法O(N)                               | 静态      |
| 数组     | 插入有序数组O(N)，随机访问topK O(1)            | 动态      |
| 链表     | 插入有序链表O(N)，访问topK O(K)                | 动态      |
| 红黑树   | 插入O(log(N))，中序遍历获取topK O(log(N))      | 动态      |
| 最小堆   | 维护topK的最小堆，插入O(log(K))，访问topK O(1) | 动态      |

**扩展：求中位数(No.K)**
| 数据结构       | 描述                                                                                | 静态/动态 |
|----------------|-------------------------------------------------------------------------------------|-----------|
| 数组           | 快速选择算法O(N)                                                                    | 静态      |
| 数组           | 插入有序数组O(N)，随机访问中位数O(1)                                                | 动态      |
| 链表           | 维护两个指向中间节点的指针，插入有序链表O(N)，访问中位数O(1)                        | 动态      |
| 红黑树         | 每个节点维护该子树的节点数，插入O(log(N))，访问中位数O(log(N))                      | 动态      |
| AVL树          | 用两子树的节点数做平衡因子，插入O(log(N))，访问中位数O(1)                           | 动态      |
| 最小堆与最大堆 | 使大数最小堆与小数最大堆的大小平衡，先插入小数最大堆，插入O(log(N))，访问中位数O(1) | 动态      |

**扩展：求频度topK，动态插入且频度可变**
| 数据结构               | 描述                                                                                           |
|------------------------|------------------------------------------------------------------------------------------------|
| 链表 + hash表          | hash表(id, ptr+data)，插入O(N)，删除O(1)，更改O(N)，访问O(1)，若频度非突变则插入与更改接近O(1) |
| 红黑树/跳跃表 + hash表 | hash表(id, ptr+data)，插入O(log(N))，删除O(log(N))，更改O(log(N))，访问O(1)                    |


# 海量数据处理
**注意**：整数的重复性有关的哈希统计可考虑Bloom Filter或bitmap

* 问：找出文件A、B的共同数据？
* 答：哈希取模，文件作桶，哈希统计，依序对比


* 问：找出海量数据中的（不）重复值？
* 答：哈希取模，文件作桶，哈希统计


* 问：统计海量数据的频度？
* 答：哈希取模，文件作桶，哈希统计


* 问：对海量数据进行排序？
* 答：分块，排序，归并


* 问：海量数据中找出topK？
* 答：动态topK算法：维护红黑树节点子树大小、维护topK最小堆


* 问：分布式处理，海量数据分布在N台主机中，求topK
* 答：每台主机求topK，然后汇总归并取前K


* 问：分布式处理，海量数据分步在M台主机中，求频度topK
* 答：哈希取模，主机作桶，哈希统计，求topK，汇总归并取前K


* 问：海量字符串去重
* 答：trie tree


# 其他问答
* 问：平时怎么学习？最近在学什么技能？
* 答：学习的话我个人比较喜欢看纸质书，我看别人都喜欢看视频来学习，这我确实不太喜欢看视频。
因为我觉得书本、文字里蕴含的知识量，真的视频是没法比的。特别是当初看csapp的时候，真得感觉字里行间都蕴含着知识。
其次的话，看书好做笔记呀，也很方便查阅。除了买书来看，就是在网上查阅一些大神写的博客，和官方文档，
比如最近在学的python和MySQL，都大量查阅了官方文档。
python跟着文档走我4天就把基本语法给学完了，然后就把笔记做好之后就暂时放下没去深入。
MySQL的官方文档没有中文的，所以学的比较慢，就官方文档配合《高性能MySQL》看。

# 反问
* 项目组里C++标准大概都是用的哪版？
* 需要我补充哪方面的知识或者锻炼哪方面能力呢？
* 项目？

# HR问答
* 问：有考研的打算吗？
* 答：并没有打算考研。因为为从自己的观察呀、从网上呀、还有包括鹅厂wo谈会上，
有个面试官就说，从他的经验上来看，研究生和本科生的能力差别其实并不大，而且本科生在本科阶段就获取的能力
可能就比研究生多花了几年时间获得的能力差一点点。他说，这么看来其实本科生还是有点优势的。
我自己也很认同这个观点，对我来讲，考研对比工作的优势仅仅在于那一纸文凭，而对于能力的提升的话我觉得肯定是直接工作要更好。
而且如果秋招有机会的话，我也希望能来腾讯，来微信。
> 虽然我第一志愿投的是IEG，但是并代表我真的想去IEG。
> 就像我当年添高考志愿选专业的时候，其实我们学生哪对这些专业了解这么多呀，都是凭主观意向随意选的。
> 既然这次微信把我捞了，我当然是很感谢微信的，而且那期鹅厂wo谈会就讲的微信，我觉得微信真得很好啊。
> 所以我很愿意加入微信，而不是考研。

在 hr 面自己也可以问一问公司的一些情况，比如
* 薪资结构
* 年终奖
* 五险一金
* 加班情况
* 加班费计算
* 升职加薪的规章制度
* 年假安排等

# STAR法则
问题：请讲出一件你通过学习尽快胜任新的工作任务的事。追问：

1. 这件事发生在什么时候？                       ———————S
2. 你要从事的工作任务是什么？                   ———————T
3. 接到任务后你怎么办？                         ———————A
4. 你用了多长时间获得完成该任务所必须的知识？   ———————深层次了解
5. 你在这个过程中遇见困难了吗？                 ———————顺便了解坚韧性
6. 你最后完成任务的情况如何？                   ———————R
