# 自我介绍
面试官您好，我是来自天津工业大学22届的本科学生，我叫熊海成。
可能您看到我的简历会比较好奇我我专业。嗯，没错，我的专业就是传说中的四大天坑之一——材料。
本来当初添志愿的时候，计算机是排在材料前面的，结果阴差阳错地后来又调到了材料后面。
唉，不是当年复联三上映吗，看见钢铁侠的纳米战衣真的是帅炸的，这就是材料的力量吗？
年轻不懂事，就调了一下志愿，诶，就像当初投简历的时候，调了一下意向部门。
结果就这样，蝴蝶效应，一步步走上自学计算机之路，一路上都靠自己思考，自己领悟，
然后接触Linux，接触开源社区，接触整个圈子，
然后，现在坐在这儿来面试我最喜欢的天美。

# 项目
## SeeCheatSheets
这个项目囊括了我个人所学的绝大多数知识与技能，
包括，比如C++、Linux、Python、MySQL、Docker以及计算机基础知识、底层知识等等；
仓库里一共包含了31篇用markdown撰写的文章笔记，总计14000行，48万字，都是我的知识结晶。

其中特别是几篇与C++和Linux相关的文章，每篇都有3万字，
而且这几篇文章每篇都至少完全重写了有3遍，每次重写都是对知识的重新整理与加深理解；

这相当于是费曼学习法吧，每次写文章作笔记都是一个与自己对话的过程，给自己讲解每一个知识点，
最后将知识吸收变为自己的理解然后记录都文章里。
这也是这个项目本来的目的，以备我经常需要复习时回头来看，可以迅速抓住重点。

除了这些理解性的知识之外，仓库里还有许多记忆性的知识，比如C++标准库、Unix系统接口、Linux命令参数等等；
为了方便快速查询这些笔记，我用C++编写构建了一支程序，用于根据关键字地搜索笔记片段并打印到终端屏幕上。
因为我平时学习和生产环境都是在终端命令行里进行的，所以也并没有特地去编写GUI版本的程序。

除了搜索笔记，这个程序更重要的功能其实在于对markdown文本进行语法高亮。
这些文章笔记都是用markdown语法写的，程序将笔记片段搜索出来后，
利用ANSI escape序列对文本进行解析着色然后在终端将其打印出来。
项目的github主页上展示了有效果图。

技术上的特点话，主要就是围绕其可扩展性进行设计吧；
因为markdown本身语法由许多语法区块构成，比如列表区块、引用区块、代码区块等等；
不仅如此，不同版本的markdown语法都有各自独特的语法元素，比如github风味的版本就支持@用户和提及issue，
markdown的作者都没有官方地统一标准，所有很有必要去思考如何提高程序的可扩展性；

我的设计上呢，首先就是为不同的语法模块设计一个抽象基类，这个抽象基类的接口大致有3个：
* 第一个方法用于判断当前行是否为某语法区块的开头
* 第二个方法用于判断当前行是否为某语法区块的结尾
* 第三个方法就是对当前语法区块中的文本进行语法解析并高亮

但这时候问题出现了，因为基于这个设计上，一个语法模块可能依赖于另一个类型的语法模块；
比如说，大多数语法块都依赖解析普通段落的语法块，用它进行部分的语法解析高亮，
还有比如判断是否结束列表语法区块就依赖于当前行是否是引用语法块的开头等等；
如果各个语法模块之间直接相互引用的话，会导致模块间非常高的耦合度，从而导致各个模块没法独立的变换扩展，
只要对一个模块进行修改扩展，就要同时修改其他所有依赖它的模块；
这时候为了降低各个语法模块间直接相互引用而导致的耦合，就需要引入中介者模式；

首先我需要设计一个中介者类，所有属于同一个markdown语法版本的语法模块都向同一个中介者注册自身，
各个语法模块与其他语法模块间的相互调用都需要通过中介者来进行，
这样每个语法模块都可以独立的修改扩展而不影响到其他模块，
实现上就是在中介者内部用哈希表键值对来存储各语法模块的指针，
注册时，比如列表区块就注册键值为list，引用区块就注册键值为quote等等；

同时，因为中介者聚集封装了各个语法模块而形成一个用于完整解析Markdown语法并高亮它的类，
这样中介者去除也算是一个表观模式中的表观类吧；

除此之外，还有一个特点是，我在语法模块的抽象基类的构造函数中做了手脚，
使得所有派生自它的子类在构造其对象实例时都自动地向中介者注册自身，这就需要在这之前有一个中介者实例对象；
为了实现这个功能，我将之前说的中介者类再加一层设计模式，把它设计成单例模式；
这样我们可以在基类构造函数中就直接向那个中介者单例注册自身，而用户也只能使用这个我们已经搭配好的单例；

这样设计下来，每当我们要设计添加一个语法高亮模块时，就先派生自抽象基类，然后实现基类接口，最后定义一个静态变量；
当程序启动后，在调用main函数之前，会先调用静态变量的构造函数，
这样就会调用基类的构造函数，然后自动地向中介者单例注册那些引入的语法模块。
而语法模块的设计分为两部分，两个文件，
一个是头文件，里面有派生类的定义，以及该派生类的一个inline的静态变量，
另一个是实现文件，就是实现了头文件中的接口。
这样，只要在主模块文件中include语法模块的头文件，就相当与引入了该语法模块。

这里有个问题就是，多文件编译时静态变量的构造顺序是未定义的，
也就是说如果我们用简单的全局变量来实现单例模式的话，语法模块类实例很可能会先于中介者单例构造的，
而语法模块的构造又需要向中介者单例注册，由此会产生错误。
这时候就需要reference-return技术来实现单例模式，
就是设计一个Instant()函数，函数内部定义有中介者类型的局部静态变量，然后函数返回这个局部静态变量。
函数局部静态变量在第一次调用函数时才会初始化，同时C++标准保证了函数局部静态变量的线程安全性；
这应该算是最简单的一种单例模式了吧；

大概设计架构就是这样，剩下的就是语法解析算法的实现了。
解析算法上比较特殊的就是标题区块与代码区块的语法解析吧，
这两个语法模块解析都需要获取终端窗口大小，这就需要调用Posix标准的系统api来获取，
同时也需要计算每一行字符的显示宽度，这就涉及到了简历上第四个项目了。
最后的话，就是普通段落区块的解析算法比较麻烦，需要用栈来记录行内emphasize元素的开启与关闭，
比如斜体粗体呀、内联代码、下划线等等，关闭的时候需要结束当前元素颜色显示，同时恢复外层元素的颜色显示。

* 问：如何实现在基类构造函数中注册派生类实例？
* 答：这就涉及到C++的多态原理。派生类的数据成员其实可看作两部分，一个是派生类部分，一个是基类部分。
如果类中定义了有虚函数，就会引入一个隐式的数据成员——虚指针，虚指针指向虚表，
虚表里存储了虚指针所在类的运行时的真实类型信息，以及该运行时类型的虚函数入口地址；
派生类部分与基类部分都有虚指针，所以我们基类的this指针就相当于把派生类的指针转换为基类指针，从而形成多态，
然后通过指针调用虚函数时，就会根据指针找到虚表，然后找到相应的虚函数入口地址，这个过程就是动态绑定。

* 问：为什么要将中介者设计成单例模式？
* 答：因为想要在基类构造函数中就实现注册派生类实例，就必须提前存在一个中介者实例，
如果用全局变量实现这个实例的话，用户很可能不会使用这个全局变量；
所以就用单例模式，这样开发者与用户都会使用相同的中介者。
当然这种设计会一定程度的降低可扩展性，因为语法模块内部都是直接引用的中介者，导致扩展中介者类时很麻烦。

当然，其实这也不算问题，因为扩展中介者类就意味着我们想要扩展不同的markdown语法版本。
我的设计上已经将各个语法模块都分离到单独的源文件中，并用头文件做接口桥梁。
这样一来，当我们想使用不同的markdown版本，就只需要引入不同版本对应的语法模块的头文件，进行排列组合即可。
只是这样一来，在运行时就只能有一个版本，但对我来说这是可接受的，毕竟这种设计很方便也很有趣。

如果正常设计的话，就老老实实地手动向中介者注册语法模块（比如在中介者的构造函数中），
然后对中介者类进行派生以适用于不同版本风味的markdown语法。

## DotFiles
这个项目其实也没啥说的，就是作为两年多的Linux用户、Linux的热爱者，我自己所积累下来的整个开发环境的配置。
项目里提供了一个Shell脚本，可完整的还原我自己的整个开发环境，方便我重装，俗称“折腾”嘛。
折腾了两年下来，其实更重要的是这个过程而非结果。

这期间我得学会不断地去发现问题、定位问题、搜索解决方案、尝试自己解决，经常会引发我自己去思考一些底层的设计原理。

> 比如说git这个版本管理器，想要真正掌握git就必须去学习去思考它是如何设计的，为什么这样设计。
> git作为一个分布式版本管理系统，如果我们克隆仓库的时候不加额外的参数，
> 就会直接把所有的历史提交记录都克隆下来，作为一个全节点，只有网络中还存在一个项目克隆备份，就可以完整地恢复该项目。
> 而想要用git管理项目，管理提交历史，管理分支都需要我们去学习它的原理。
> git管理的历史数据其实有4大部分组成：
> * 第一个是对象，其实就是每个文件的修改提交后的全量备份，俗称“文件快照”
> * 第二个是树，树负责指向一系列对象，这些对象都是同属于某个历史节点的“文件快照”，由此组成整个项目在当前历史节点上的“快照”
> * 第三个是提交信息，包含了一颗树代表历史快照，还记录了一些关于历史节点的提交信息，比如提交者姓名、邮件、提交描述等等
> * 最后一个就是指针，指针指向一个提交信息，而实际上分支其实就是在历史节点上移动的指针
> 
> 知道了这些原理之后，我也就知道了整个项目的历史，其实就是一个个commit节点构成的一个存在分叉的链，
> 于是也就知道了，分支切换与历史回溯也就是将HEAD指针指向版本链上的某一节点，
> 也就知道了，分支合并其实就是对合并节点的树进行调整，合并的树会指向两分支的树所指向的对象的交集，
> 对于非交集部分的同名文件，会首先判断该对象是否只有其中一个分支相对两分支共同祖先进行了修改（添加和删除文件都没视作修改），
> 如果是则合并的树会指向修改的对象，如果两个分支都修改了，则中断合并过程，等待用户手动修复。

又比如国内DNS污染问题，我经常访问github会受到域名污染的问题，特别是校园网。
一开始我不知道域名污染，我想应该不止我一个人访问github很慢吧，我就去搜“github访问很慢怎么办”？
结果就知道了，哦，是域名污染的原因，根据我学的计算机网络的知识，知道DNS在网络中扮演什么样的角色，
也就明白为什么改hosts文件会有效果。

后来不满改hosts的方法非常麻烦，特别是对于github博客的域名，就是github.io，每个博客的域名都是不一样的，
所以没法通过修改hosts文件来解决，于是我就想，有没有其他方法从根上解决域名污染呢？
诶，我就想到直接用github的权威DNS服务器，这样就不会有域名污染的问题了吧。
实验倒是成功了，但是速度有点感人，太慢了。
然后我就想，能不能只对github的域名使用他家权威DNS服务器，就是对于指定的域名使用指定的DNS服务器来解析。
然后我就去搜，在stackoverflow上找到了答案，说是linux内核并不支持这样做，需要自己搭建DNS服务器。
然后就顺藤摸瓜，去修改NetworkManager服务的配置，去搭建dnsmasq服务，当然其中还有一些问题，不过最终都被我解决了。

就像这样，问题一个一个得被解决，配置越来越多，开发环境越来越舒服。
所以这个项目对我来说，是一个我成长的过程吧。

## SpaceVim
SpaceVim是一个社区驱动开发的模块化的vim发行版，它利用模块的形式来管理插件集合。
项目的背景就是当年vim配置群魔乱舞，现在有了SpaceVim其实很大程度上改善了这一状况，
同时降低了vim门槛，对新手更加友好。

项目中模块化管理确实是一个非常棒的设计，如今SpaceVim有这么多包括我在内的贡献者其实模块化设计作了很大贡献。
因为当我们作为开源贡献者发现项目里有一些问题、bug或者想要添加、修改一些特性时，
我们可以根据这样模块化的设计，很容易找到相应源文件，然后进行修复或二次开发。
确实是哪里不顺改哪里，精准打击。

这个项目中我扮演的角色，或者说完成的任务，做出的贡献吧，就是修复了一些bug和添加了一些特性吧。
技术上没有特别难的点，特别难的都让上游给做了。
我更多的是解决各种各样的bug，缝缝补补，以及对文档的补充吧，
毕竟是我第一次大规模的阅读别人的代码，其实还是很有挑战的。

我作为其中一个开源贡献者，虽然对上游贡献的不多，提交PR的次数很少。
但我在我自己fork的分支版本中修改了大量的源码，总共修改了有46个源文件，累计修改了将近4000行源代码。

我就说说我自己作了哪些修改吧：
* * * * * * * * * *
* **图标**：基于文件名、基于vim内建类型
* * * * * * * * * *
* **自动补全**：语义补全引擎与结对符补全，issue，实现
* * * * * * * * * *
* **语法检测**：cppcheck、clangtidy
* * * * * * * * * *
* **颜色主题**：针对C++
* * * * * * * * * *
* **字符画**：独角兽、不可描述
* * * * * * * * * *
* **状态栏**：算法修改，根据当前窗口宽度来选择展示的内容，行列号
* * * * * * * * * *
* **Fcitx与Fcitx5**：四种状态、问过上游
* * * * * * * * * *
* **FlyGrep文件内容搜索**：大小写敏感，PR
* * * * * * * * * *
* **QuickRun快速代码运行**：替代上游
    * 内建终端（方便）
    * 计时器（Linux api、更精准、派生子进程、前台进程组、信号、返回码、中断信号）
    * CGroup限制内存使用
    * 自动检测时间戳
    * 窗口隔离
    * 参数设置（设置编译器参数、运行命令、IO重定向）
    * 无伤移植
* * * * * * * * * *
* **文件树**：绑定快捷键到GUI程序
* * * * * * * * * *
* **tmux**：交互
* * * * * * * * * *
* **C模块**：三个插件（语义补全引擎、语法检测引擎、我的代码快速运行插件）统一C++标准版本。
* * * * * * * * * *
* **文档**：精简齐全，不用过脑
* * * * * * * * * *


> 但是由于整个项目基本上都是使用vim自带的脚本实现的，我自己对vim的各个api函数不太了解，
> 所以经常需要边修改边去查阅文档，现学现卖，甚至有些时候还要和上游维护者交流一下，向它们请教一下。
> 项目的维护者们建了有在线聊天室，经常有问题就会在聊天室里提出来，商量解决方案。
> 当需要正式修改的时候就要走在流程，先提issue，再提pr，最后review合并。
> 因为我经常在群里发言，他们就注意到了我自己fork的分支版本，觉得很不错，说我要是觉得有什么特性可以合并的提pr就行。

整个项目对我而言，其实是对我自身综合能力的锻炼吧，毕竟这么大个项目，团队合作很重要。
而且这也是我自身第一次大量的阅读别人的源码，而且还是自己没熟练掌握的语言，
所以对我而言，需要大量的思考别人的设计，才能修改成我想要的样子。


* 问：怎么得到4000行这个数据的呢？
* 答：就是用grep和awk编辑三剑客处理一下git diff的输出得到的。在git diff的输出中，-号开头表示删除，
+号开头表示添加，我就计算一下+号开头的有多少行，结果大概就是3800行左右。

# 其他问答
* 问：平时怎么学习？最近在学什么技能？
* 答：学习的话我个人比较喜欢看纸质书，我看别人都喜欢看视频来学习，这我确实不太喜欢看视频。
因为我觉得书本、文字里蕴含的知识量，真的视频是没法比的。特别是当初看csapp的时候，真得感觉字里行间都蕴含着知识。
其次的话，看书好做笔记呀，也很方便查阅。除了买书来看，就是在网上查阅一些大神写的博客，和官方文档，
比如最近在学的python和MySQL，都大量查阅了官方文档。
python跟着文档走我4天就把基本语法给学完了，然后就把笔记做好之后就暂时放下没去深入。
MySQL的官方文档没有中文的，所以学的比较慢，就官方文档配合《高性能MySQL》看。

# 反问
* 项目组里C++标准大概都是用的哪版？
* 需要我补充哪方面的知识或者锻炼哪方面能力呢？

# HR问答
* 问：有考研的打算吗？
* 答：并没有打算考研。因为为从自己的观察呀、从网上呀、还有包括鹅厂wo谈会上，
有个面试官就说，从他的经验上来看，研究生和本科生的能力差别其实并不大，而且本科生在本科阶段就获取的能力
可能就比研究生多花了几年时间获得的能力差一点点。他说，这么看来其实本科生还是有点优势的。
我自己也很认同这个观点，对我来讲，考研对比工作的优势仅仅在于那一纸文凭，而对于能力的提升的话我觉得肯定是直接工作要更好。
而且如果秋招有机会的话，我也希望能来腾讯，来微信。
> 虽然我第一志愿投的是IEG，但是并代表我真的想去IEG。
> 就像我当年添高考志愿选专业的时候，其实我们学生哪对这些专业了解这么多呀，都是凭主观意向随意选的。
> 既然这次微信把我捞了，我当然是很感谢微信的，而且那期鹅厂wo谈会就讲的微信，我觉得微信真得很好啊。
> 所以我很愿意加入微信，而不是考研。


