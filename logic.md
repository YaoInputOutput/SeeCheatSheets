# 目录
<!-- vim-markdown-toc GFM -->

- [循环](#循环)
- [分支](#分支)
- [递归](#递归)
- [步数](#步数)

<!-- vim-markdown-toc -->

# 循环
0. 设计**多重循环**时，抓住各层循环的**循环变量**及其迭代的**先后顺序**进行设计  
1. 循环变量
    * 确定**循环变量**
    * 思考**如何迭代**该循环变量
    * 若迭代变量的更新步数不确定，可用**`if{continue}`**跳过部分循环
2. 条件检测
    * 确定**检测条件**，注意**until与while**的逻辑关系
    * 可以依据**相关关系**确定检测条件或迭代位置
    * 注意优先检测**穷尽条件**
3. 循环操作
    * 确定**循环操作**的内容，标记出所有**需要更新的对象**
    * 修正**初始状态**
        > 若初始状态需要的变量太多或语句太复杂，
        > 则将初始化语句放在循环体之前，或转换为`for{if{break}}`（见下）
    * 若**第一次循环**需要特殊操作，可以
        * 将第一次的循环操作提取出来放到循环体前面
        * 或者利用onceFlag标记第一次
    * 判断用**`for`还是`while`**，
        for循环用于**需要初始化头部**和**continue时仍需要迭代变量**的情况，其它情况用while
4. 最后收尾
    * 将**最终状态的参数**带入检查是否正确
    * **尾后处理**，例如处理剩余的元素

* 检测条件的确定：循环变量与循环操作的相关关系
    * 同步相关（计数器）：检测最后操作状态
    * 异步相关**迭前操后**：检测最后操作状态
    * 异步相关**迭后操前**：检测最后操作状态+1

# 分支
首先要明确分支操作所需要的条件
* `if-if`                               ：可能同时发生的条件
* `if-else`与`if{continue或return}`     ：不可能或不应该或没必要同时发生的条件，若需要跳过的语句不多则选择前者
* `if-elseif-else`与`if-else{if-else}`  ：有公共语句则前者转为后者，无则后者转前者
* `for{}与for{if-break}`                ：若条件检测需要插在循环操作之间进行，则使用`if-break`
* `if{for}`
    * 条件：if与for的检测条件重合时
    * 目的：某条件下需要进行循环操作
    * 合并：只要for，if的语义用for的初始条件替代
* `for{if{for}}`
    * 条件：外层for与内层for的检测条件重合时
    * 目的：在某条件下用另一种方式完成循环
    * 合并：外for内嵌if-else，注意变量迭代是否有差异
        > 当然合并可以简化代码，但可能导致性能降低，因为每次循环都要多个条件检测

# 递归
* 设计步骤：
    * 函数功能：明确递归的所有作用、参数、返回值
    * 基准情况：结束递归并保证函数功能符合
    * 一般进展：一次递归只做部分，其余部分调用递归函数做，结合后返回时对调用者也符合函数功能
* 注意：
    * 递归的结束尽量用**基准情况**来控制，并且尽早的检查结束条件
    * 尾递归尽量地转换成循环语句
    * 可以用Stack来存储递归途径

# 步数
数量：
* `[X0, Xn]`
* Xn - X0 + 1

距离：
* `(X0, Xn]`
* Xn - X0

加减的物理意义：加减的对象是距离
* `X0 + n` => `(X0, X1, ..., Xn]`
