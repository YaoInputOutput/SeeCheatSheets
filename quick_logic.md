# 编码经验
## 边界条件
* 数值限制
    * 整数（U负溢出、-Tmin、除零）
    * 浮点（精度、结合、比较、除零）
    * 空指针
    * 同引用参数
* 容器循环
    * 极小容器
    * 前后依赖
    * 循环边界

**解决方案**：
* 提前处理
* 极值替换
* 额外节点
* 反转大小

**用户接口**：
* 发射信号
* 抛出异常
* 静默处理

## 循环
* 变，语，迭    > if-continue
* **条**，穷，相    > if-break
* **操**，记，初    > once

**补充**：
* 相关关系：
    * 若在条件检测中使用 **前缀** 自增或自减会导致
        **检测前初始状态** 额外地+1，但仍属于 **检测最后状态+1** 
    * 若在条件检测中使用 **后缀** 自增或自减会导致
        **检测后初始状态** 与 **最后状态** 额外地+1，属于 **检测最后状态**

* 循环计数器：空操作无所谓迭前迭后，迭代至目标状态即可

* 初始状态：若构造循环 **初始状态** 的代码与循环体内片段重复，则将条件检测延迟到if-break语句中

* 如果第一次循环存在特殊操作：
    * 改变初始状态，将第一次循环操作抽出
    * 利用once标识，只在第一次循环执行特殊操作
    * 观察是否可转换为最后一次循环做特殊操作

* 如果最后一次循环存在特殊操作：
    * 改变条件检测，将最后一次循环操作抽出
    * 利用if-break代替头部条件检测，在最后一次循环时执行特殊操作
    * 观察是否可转换为第一次循环做特殊操作


## 分支
> 注意：首先判断两事件是否可以同时发生
* if-if
* if-else if-continue if-break if-return if-exit
* if-elif-else  `<=>` if-else{if-else}
* 多if `=>` switch `=>` 跳转表（数组） `=>`跳转表（hash表）

> 对于if-elif-else  `<=>` if-else{if-else}：
> * 保证合并后的else条件包含原来两分支的条件，即逻辑或语义（仅合并else分支是因为否则需要检测两次条件）
> * 有时两分支的条件检测有部分重叠时，也可合并两分支


## 递归
* 明确功能：参数、返回值、所有副作用
* 基准情况：结束递归，并符合上述功能
* 一般进展：利用递归获取下层结果，与本层计算结合得到本层结果
* 尾递归：转为循环

## 步数
* 获取数量：
    * `[X0, Xn]`
    * Xn - X0 + 1
* 获取距离：
    * `(X0, Xn]`
    * Xn - X0
* 获取尾后向量：
    * Xn + 数量
* 获取尾部向量：
    * Xn + 距离

# 解题思路
## 逆向思维
* 求起点的终点转为求终点的起点
* 对多个元素进行操作，相当于对其他元素进行相对逆操作
* 由结论出发，向所求条件逆推


## 栈
**关键字**：层级、递归、后进先出


## 队列
**关键字**：滑动窗口、先进先出


## 单调栈
**关键字**：单调排列、最近较大/小值

特点：以单调递减栈为例
* 对出栈元素来说：
    * 入栈元素是其右侧最近的较大值
* 对入栈元素来说：
    * 栈里的元素即其左侧单调排列的元素（忽略破坏单调性的元素）
    * 成功入栈后栈顶第二个元素即其左侧最近的较大值


## 单调队列
**关键字**：滑动窗口最值


## 二分搜索
**关键字**：搜索有序序列
```cpp
/**************************************************************************************************/
// 版本一：目标语义为范围
/**************************************************************************************************/
// 步骤一：判断循环终止条件
while ( left < right ) {        // 不能使用left <= right，因为当left == right && check(mid)为true则会死循环
    mid = (left + right) / 2;
// 步骤二：选取 right 做语义边界
    if ( check(mid) )           // 不用left做语义边界，
        right = mid;            // 因为语义边界迭代更新需要使用left = mid语句，
    else                        // 而mid向下取整可能等于left，
        left = mid + 1;         // 若left == mid && check(mid)为true则会死循环
}
// 步骤三：检测 right 具体目标语义是否满足
if ( check(right) )             // right初始位置可能不满足，且right位置一直未变动
    pass;
/**************************************************************************************************/
// 版本二：目标语义为确定值
/**************************************************************************************************/
while ( left <= right ) {       // left <= right可以保证每个元素都被accurateCheck(mid)检测过
    mid = (left + right) / 2
    if ( accurateCheck(mid) )   // mid作为语义点
        return mid;
    else if ( check(mid) )      // left与right均为驱动边界
        right = mid - 1;
    else
        left = mid + 1;
}
// 没有在循环中return说明未找到语义点
```

## 数组
**关键字**：路径搜索、路径染色、回溯算法  
**细节**：注意返回前是否需要清除染色或弹出路径节点

**关键字**：子数组、子序列、逆向首尾、递归分解、动态规划  
**细节**：记忆表中数据可能与初始状态结果不相等

**关键字**：跳跃遍历、滑动窗口  
**细节**：辅助表类型：覆盖型、叠加型、抵消型、语义型

**关键字**：数值范围0~N
* 原数组做哈希表
* 数值范围二分

## 链表
* 双指针，一前一后
    > 迭代更新prev指针时，最好使用prev=cur，如此一来无论是否删除节点都适用
* 双指针，一快一慢
    > fast先行两步，若成功则slow后行一步，如此一来slow会在奇数时停在中点，偶数时停在较小中点
* 双指针，间隔距离
* 哑节点，简化边界
    > 反转链表时，哑节点为nullptr

## 二叉树
**深度优先搜索(DFS)**
* 先序遍历：序列首元素为根节点
* 后序遍历：序列尾元素为根节点
* 中序遍历：根节点将序列分为左右两边
    > 中序遍历也即二叉搜索树的有序遍历；注意其下个节点的搜索算法

**细节**：注意记录路径或染色路径时，注意是否每次都需要弹出路径节点或清除染色，还是在未搜索到结果时才需要

**广度优先搜索(BFS)**

## 位运算
* 位与(&)：有0则0、0归零1取值、1不变0归零
* 位或(|)：有1则1、0不变1存值
* 异或(^)：同为0异为1、0不变1取反、同归零
* 取反(~)：~x == -x - 1
* 1位数量：x &= (x - 1)

## 模运算
* 同余方程
    * $(a - b) \\\% N = 0$
    * $a \equiv b \mod N$
    * $a+c \equiv b+c \mod N$
    * $a \times d \equiv b \times d \mod N$
* 求余方程
    * $(a + b)\\\% N = (a\\\% N + b\\\% N)\\\% N$
    * $(a \times b)\\\% N = (a\\\% N \times b\\\% N)\\\% N$
    * $(a - b)\\\% N = (a\\\% N - b\\\% N + N)\\\% N$
    * $(a \div b)\\\% N = (a \times b^{-1})\\\% N$
* 求模运算
    * 截位取值（字符转数字从前往后，数字转字符串从后往前）
    * 数值回环

# topK算法
| 数据结构 | 描述                                           | 动态/静态 |
|----------|------------------------------------------------|-----------|
| 数组     | 快速选择算法O(N)                               | 静态      |
| 数组     | 插入有序数组O(N)，随机访问topK O(1)            | 动态      |
| 链表     | 插入有序链表O(N)，访问topK O(1)                | 动态      |
| 红黑树   | 插入O(log(N))，中序遍历获取topK O(log(N))      | 动态      |
| 最小堆   | 维护topK的最小堆，插入O(log(K))，访问topK O(1) | 动态      |

**扩展：求中位数(No.K)**
| 数据结构       | 描述                                                                                | 静态/动态 |
|----------------|-------------------------------------------------------------------------------------|-----------|
| 数组           | 快速选择算法O(N)                                                                    | 静态      |
| 数组           | 插入有序数组O(N)，随机访问中位数O(1)                                                | 动态      |
| 链表           | 维护两个指向中间节点的指针，插入有序链表O(N)，访问中位数O(1)                        | 动态      |
| 红黑树         | 每个节点维护该子树的节点数，插入O(log(N))，访问中位数O(log(N))                      | 动态      |
| AVL树          | 用两子树的节点数做平衡因子，插入O(log(N))，访问中位数O(1)                           | 动态      |
| 最小堆与最大堆 | 使大数最小堆与小数最大堆的大小平衡，先插入小数最大堆，插入O(log(N))，访问中位数O(1) | 动态      |

**扩展：求频度topK，动态插入且频度可变**
| 数据结构               | 描述                                                                                           |
|------------------------|------------------------------------------------------------------------------------------------|
| 链表 + hash表          | hash表(id, ptr+data)，插入O(N)，删除O(1)，更改O(N)，访问O(1)，若频度非突变则插入与更改接近O(1) |
| 红黑树/跳跃表 + hash表 | hash表(id, ptr+data)，插入O(log(N))，删除O(log(N))，更改O(log(N))，访问O(1)                    |


# 海量数据
**注意**：整数的重复性有关的哈希统计可考虑Bloom Filter或bitmap

* 问：找出文件A、B的共同数据？
* 答：哈希取模，文件作桶，哈希统计，依序对比


* 问：找出海量数据中的（不）重复值？
* 答：哈希取模，文件作桶，哈希统计


* 问：统计海量数据的频度？
* 答：哈希取模，文件作桶，哈希统计


* 问：对海量数据进行排序？
* 答：分块，排序，归并


* 问：海量数据中找出topK？
* 答：动态topK算法：维护红黑树节点子树大小、维护topK最小堆


* 问：分布式处理，海量数据分布在N台主机中，求topK
* 答：每台主机求topK，然后汇总归并取前K


* 问：分布式处理，海量数据分步在M台主机中，求频度topK
* 答：哈希取模，主机作桶，哈希统计，求topK，汇总归并取前K


* 问：海量字符串去重
* 答：trie tree

