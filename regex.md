# 目录
<!-- vim-markdown-toc GFM -->

- [零宽断言](#零宽断言)
- [实体模式](#实体模式)
- [字符类](#字符类)
- [转义字符](#转义字符)
- [regex技巧](#regex技巧)
- [性能优化](#性能优化)

<!-- vim-markdown-toc -->

正则表达式的标准并不统一，此处为大多数标准都支持的，具体还得查看使用的正则引擎的文档  
笔者使用的版本一般为：C++ regex库、Vim、POSIX扩展正则工具(如sed, awk, grep)  
故以下后缀代表：
- `+cpp`代表C++ regex库支持
- `+vim`代表Vim支持（Vim默认的正则模式除了`.*^$`外的其它所有元字符需要添加`\`，可在regex前添加`\v`开启所有元字符）
- `+grep`代表grep扩展正则支持

<!-- entry begin: regex 零宽断言 -->
# 零宽断言
| 符号           | 含义         | 备注            |
|----------------|--------------|-----------------|
| `^`            | 行首         | (+cpp+vim+grep) |
| `$`            | 行尾         | (+cpp+vim+grep) |
| `\b`           | 单词边界     | (+cpp+grep)     |
| `\B`           | 非单词边界   | (+cpp+grep)     |
| `\<`           | 单词左边界   | (+vim+grep)     |
| `\>`           | 单词右边界   | (+vim+grep)     |
| `(?=pattern)`  | 顺序预查     | (+cpp)          |
| `(?!pattern)`  | 顺序否定预查 | (+cpp)          |
| `(pattern)@=`  | 顺序预查     | (+vim)          |
| `(pattern)@!`  | 顺序否定预查 | (+vim)          |
| `(pattern)@<=` | 逆序预查     | (+vim)          |
| `(pattern)@<!` | 逆序否定预查 | (+vim)          |
<!-- entry end -->

<!-- entry begin: regex 实体匹配 实体模式 -->
# 实体模式
| 符号          | 含义                                                     | 备注                      |
|---------------|----------------------------------------------------------|---------------------------|
| `.`           | 匹配除`\n`外任意字符                                     | (+cpp+vim+grep)           |
| `[...]`       | 匹配序列中的一个字符                                     | (+cpp+vim+grep)           |
| `[ - ]`       | 匹配序列中的一个字符                                     | (+cpp+vim+grep)           |
| `[^ ]`        | 匹配序列中未出现的一个字符                               | (+cpp+vim+grep)           |
| `*`           | 匹配前一个字符0 - ∞次                                    | (+cpp+vim+grep)           |
| `*?`          | 懒惰匹配版`*`                                            | (+cpp)                    |
| `{-}`         | 懒惰匹配版`*`                                            | (+vim)                    |
| `+`           | 匹配前一个字符1 - ∞次                                    | (+cpp+vim+grep)           |
| `+?`          | 懒惰匹配版`+`                                            | (+cpp)                    |
| `?`           | 匹配前一个字符0或1次                                     | (+cpp+vim+grep)           |
| `{n}`         | 匹配前一个字符n次                                        | (+cpp+vim+grep)           |
| `{n,m}`       | 匹配前一个字符n-m次                                      | (+cpp+vim+grep)           |
| `{n,}`        | 匹配前一个字符至少n次                                    | (+cpp+vim+grep)           |
| `...          | ...`                                                     | 匹配左或右的模式，用`(... | ...)`将其限制在局部 | (+cpp+vim+grep) |
| `(...)`       | 匹配组，将括号内的模式视作一个单位，组编号即左括号的顺序 | (+cpp+vim+grep)           |
| `(?:...)`     | 匹配组，但不支持反向引用                                 | (+cpp)                    |
| `%(...)`      | 匹配组，但不支持反向引用                                 | (+vim)                    |
| `\1, ..., \N` | 反向引用，替换为第N个匹配组（按`(`出现的顺序编号）       | (+cpp+vim+grep)           |
<!-- entry end -->

<!-- entry begin: regex 字符类 -->
# 字符类
| 字符类     | 内容                         |
|------------|------------------------------|
| [:alnum:]  | 字母＋数字                   |
| [:alpha:]  | 字母                         |
| [:upper:]  | 大写字母                     |
| [:lower:]  | 小写字母                     |
| [:digit:]  | 数字                         |
| [:xdigit:] | 十六进制数字                 |
| [:punct:]  | 符号                         |
| [:blank:]  | ` `与`\t`                    |
| [:space:]  | ` ` `\t` `\n` `\r` `\v` `\f` |
| [:cntrl:]  | `\x00`-`\x1F` 与 `\x7F`      |
| [:graph:]  | `[[:alnum:][:punct:]]`       |
| [:print:]  | `[[:alnum:][:punct:] ]`      |
<!-- entry end -->

<!-- entry begin: regex 转义字符 -->
# 转义字符
| 转义字符                 | 含义                          | 备注                            |
|--------------------------|-------------------------------|---------------------------------|
| `\d` `\D`                | `[[:digit:]]、[^[:digit:]]`   | (+cpp+vim+grep)                 |
| `\s` `\S`                | `[[:space:]]、[^[:space:]]`   | (+cpp+vim+grep)                 |
| `\w` `\W`                | `[[:alnum:]_]、[^[:alnum:]_]` | (+cpp+vim+grep)，grep还包含中文 |
| `\n` `\r` `\t` `\v` `\f` |                               | (+cpp+vim)                      |
| `\0` `\xhh` `\uhhhh`     | null字符、ansi、unicode       | (+cpp)                          |
| `\a` `\b` `\e`           | 警报、退格、escape            |                                 |
| `\x` `\X`                | `[[:xdigit:]]、[^[:xdigit:]]` | (+vim)                          |
| `\l` `\L`                | `[[:lower:]]、[^[:lower:]]`   | (+vim)                          |
| `\u` `\U`                | `[[:upper:]]、[^[:upper:]]`   | (+vim)                          |
| `\a` `\A`                | `[[:alpha:]]、[^[:alpah:]]`   | (+vim)                          |
<!-- entry end -->

<!-- entry begin: regex 技巧 -->
# regex技巧
* `[^y]x*[^y]`：企图避免在连续x前后马上接y（错误）。考虑匹配`yxxxy`时，`x*`匹配`x`，前一个`[^y]`匹配第一个`x`，后一个`[^y]`匹配第三个`x`，
    因为`x*`的连续匹配提前结束，故应该这样写regex：`[^yx]x*[^yx]`

* `[^x]*y`：企图避免在y前面出现x（错误）。因为`[^x]*`可以匹配nothing，即什么也不用匹配也算作匹配成功。
    故应该这样写regex：`^[^x]*y`

* `[^x]y`：企图避免在y前面相邻位置接x（错误）。因为未考虑y前面"没有字符"的情况。
    故应该这样写regex：`([^x]|^)y`

* 利用逆向思维，将**不应该在某位置出现什么**，转换为**应该在某位置出现什么**，注意**该位置**是否可以为空
<!-- entry end -->

# 性能优化
* Character Classes：替换掉`.`转而用更小的范围，即使是`[^ ]`也会有大幅提升
* 适当使用零宽断言
